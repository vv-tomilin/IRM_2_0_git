<?xml version="1.0" encoding="UTF-8"?>
<script>
  <metadata>
    <icon type="image/png">iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAA3NCSVQICAjb4U/gAAAACXBIWXMAAA7EAAAOxAGVKw4bAAADyElEQVRIibVWvU8jVxD/vd2HP86Ag+zkIAUIFAFCFOQioTSRIqV2RQ8tgpIi/wFNSiQ3qagokNIgcQ1NGmSdhCUkJAcio+QiIizsGOPbW5t9M5Nid/25KDkdN35aze7M+/1m5+N5VS6Xw6cUDWAi7c3PuiKAAABEQiVc+BAl1H+vvqi7IxrA/Kz74+ZbEMAACRidJYzgeWcRIBCW0B9P+f/068ybv9KWH3H4NApd+gl60YdXr78AgBW8mo/eY+6iD8bYg95PLwP+EtYACDMjAEF6N/djDWYmdIiIhqSHQKQnwMHN/533CP+wTUKCJxL6P6s66C8BYOcN/vw7+fMvX/r3wv0N113Sdxvt02f9o5EICCr/xF6fZj56pKJFAxif8WZ+cA3BEIhgjPhKu24334x+9+33GxsbkZv39/eLxeLOzs709PSwdW9vr1gsagDKhkqIIigjIMAGCGyEtQKQSCQymej3SyQSlmWl0+lIh1gsBn8OWGDCwI2BIXi+zjK87UNFAzDv1cNbmxhMMAwiEIFYvKYljFqtdn5+Hrm5VqsZY66urprN5rC10WgAULlcTmnRKYZ0myXQCWjZqRepiYmJSIJ6ve66bjab9bMxINVqtdVqaQB2guMvDQuYwQIJr3gEHu1MJrO8vBxJcHFxcXt7u7CwMDY2Nmw9OzsLCPRnNP6N64U18AyERAyoYev7+NLS0ubmZiRBPp9/eHhYW1ubm5sbtu7u7lYqleA07UU3JH6piSJhP0y0T9Dpnw66MeHp+PEEpmm//y3BDCawgFnAsBhoW0Iol8uHh4eRm8vlcqvVOjk5ieyCm5sb+F0EJbCDYLsRCwAoVrZtRzYJgMfHRyKKx+OWZQ1b2+02M2sAKm2sr1pEoJ4hIAJcO11Jvfr61VMfBkdHR6VSaX19fXJycth6cHBQKpU0ABkRSnthGcQzQT2U8LhCJpNZWVmJJDg9PdVaz8/PR3bR8fExOkWmTpFNV7GerYuMoncWE4TAJGIAgmKotgWB4zh+uYbFcRwiuru7i8fjw1bXdeEXWWyWBEvnqAhPCzBink6Pj2ez2UiCarXqOM7U1FRkF1QqFcdxNABRYFuYRQSiIAJmQAU/rfXo6Ggkwf39vVIqmUwmk8lI+iBFZtRrzL4LJpnEGBDBMxhp2Qv3E6urq1tbW5EE+Xy+UChsb28/dVQUCgWN7v9BMMY+uiGxSORZJlkkRKcu+nN1kcrlcqS5nfT81PtFZoEILFZpir38/IvIDAC4vr6u1+uLi4upVGrYenl5Wa/X1af+fP8XFKgjayWSP0cAAAAASUVORK5CYII=</icon>
    <visible>1</visible>
    <title>atvise SVG table</title>
    <description>Creates a SVG table on a GROUP (mandatory!) element.</description>
  </metadata>
  <parameter behavior="optional" defaultvalue="25" desc="row height" name="rowHeight" valuetype="number"/>
  <parameter behavior="optional" defaultvalue="true" desc="sortable" name="sortable" valuetype="bool"/>
  <parameter behavior="optional" defaultvalue="false" desc="sort ascending" name="sortingUp" valuetype="bool"/>
  <parameter behavior="optional" defaultvalue="0" desc="column to be sorted by" name="sortedByColumn" valuetype="number"/>
  <parameter behavior="optional" defaultvalue="25" desc="size of scrollbar" name="scrollbarSize" valuetype="number"/>
  <parameter behavior="optional" defaultvalue="true" desc="draw statusbar" name="drawStatusBar" valuetype="bool"/>
  <parameter behavior="optional" defaultvalue="true" desc="highlight cells" name="highlightCells" valuetype="bool"/>
  <parameter behavior="optional" defaultvalue="false" desc="row selectable" name="selectRow" valuetype="bool"/>
  <parameter behavior="optional" defaultvalue="false" desc="column selectable" name="selectColumn" valuetype="bool"/>
  <parameter behavior="optional" defaultvalue="false" desc="auto resize" name="autoResize" valuetype="bool"/>
  <parameter behavior="optional" defaultvalue="false" desc="fix selection" name="selectFixed" valuetype="bool"/>
  <parameter behavior="mandatory" defaultvalue="600" desc="height" name="height" valuetype="number"/>
  <parameter behavior="mandatory" defaultvalue="1000" desc="width" name="width" valuetype="number"/>
  <code><![CDATA[//table V2.5 with extended scroll functions

/*
 atvise table widget http://www.atvise.com/

 Copyright (C) 2008-2010 Certec EDV GmbH. All Rights Reserved.
 $Rev: 4122 $

 WARNING: This software program is protected by copyright law
 and international treaties. Unauthorized reproduction or
 distribution of this program, or any portion of it, may result
 in severe civil and criminal penalties, and will be prosecuted
 to the maximum extent possible under the law

 May only be used with explicit written authorization by Certec
*/

/**
 * The AtviseTable Class.
 * @class
 * @param {Object} tableElement An SVG Group element.
*/
function AtviseTable(tableElement) {
	var hasVML = !(document.implementation && document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1"));
	var hasSVG = (document.implementation && document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1"));

	if (tableElement != undefined && typeof tableElement == "object" && (hasVML || hasSVG)) {
		this.tableElement = tableElement;
		this.tableElement.dataProvider =		null;
		this.tableElement.headerRects =			[];
		this.tableElement.headerTexts =			[];
		this.tableElement.headerObjects =		[];
		this.tableElement.maskingFunctions =	[];
		this.tableElement.headersOutside =		0;
		this.tableElement.firstHeaderOutside =	-1;
		this.tableElement.cellRects =			[];
		this.tableElement.cellTexts =			[];
		this.tableElement.cellTextContents =	[];
		this.tableElement.sortingArrow =		null;
		this.tableElement.scrollRowOffset =		0;
		this.tableElement.scrollColOffset =		0;
		this.tableElement.selectedRow =			-1;
		this.tableElement.selectedColumn =		-1;
		this.configuration =					{};
		this.scrollbar =						{};
		this.statusbar =						{};
		this.style =							{};
		this.styleEven =						{};
		this.styleOdd =							{};
		this.hasVML =							hasVML;
		this.hasSVG =							hasSVG;
		this.isMobile =							false; //(navigator.userAgent && /iPad|iPhone|Opera Mobi/.test(navigator.userAgent));
	}
}

/*  ***********************************************************
	********** atvise table widget PUBLIC FUNCTIONS **********
	*********************************************************** */

/**
 * Adds a column to the AtviseTable.
 * @param {Number} [position] Position of the column.
*/
AtviseTable.prototype.addColumn = function(position) {
	var tableElement = this.tableElement;
	var configuration = this.configuration;
	var style = this.style;
	var column = (position!=undefined)?position:(configuration.columnCount+1);
	column--; // array starts with 0, user types in +1
	var createRows = (arguments[1]!=undefined)?arguments[1]:true;
	var textOffsetY = configuration.rowHeight - ((configuration.rowHeight/2)-(style.fontSize/2)) - 2;

	var startY;
	if(column==0)startY=0;
	else startY=parseInt(webMI.gfx.getY(tableElement.headerRects[column-1]));

	var startX;
	if(column==0)startX=0; //configuration.tableWidth;
	else startX=parseInt(webMI.gfx.getX(tableElement.headerRects[column-1]))+parseInt(webMI.gfx.getWidth(tableElement.headerRects[column-1]));

	//creates header cell&text
	if (tableElement.headerObjects[column]!=undefined) {
		this._setProperties(tableElement.headerObjects[column],style.header);
	}
	var name = (tableElement.headerObjects[column]!=undefined && tableElement.headerObjects[column].name)?tableElement.headerObjects[column].name:"";
	var width = (tableElement.headerObjects[column]!=undefined && tableElement.headerObjects[column].width)?tableElement.headerObjects[column].width:style.header.width;
	var fill = (tableElement.headerObjects[column]!=undefined && tableElement.headerObjects[column].fill)?tableElement.headerObjects[column].fill:style.header.fill;
	var fontFamily = (tableElement.headerObjects[column]!=undefined && tableElement.headerObjects[column].fontFamily)?tableElement.headerObjects[column].fontFamily:style.header.fontFamily;
	var fontSize = (tableElement.headerObjects[column]!=undefined && tableElement.headerObjects[column].fontSize)?tableElement.headerObjects[column].fontSize:style.header.fontSize;
	var fontColor = (tableElement.headerObjects[column]!=undefined && tableElement.headerObjects[column].fontColor)?tableElement.headerObjects[column].fontColor:style.header.fontColor;
	var stroke = (tableElement.headerObjects[column]!=undefined && tableElement.headerObjects[column].stroke)?tableElement.headerObjects[column].stroke:style.stroke;
	var strokeWidth = (tableElement.headerObjects[column]!=undefined && tableElement.headerObjects[column].strokeWidth)?tableElement.headerObjects[column].strokeWidth:style.strokeWidth;
	var headerRect = webMI.gfx.addRect({width:width,height:configuration.rowHeight,x:startX,y:startY,fill:fill,stroke:stroke,strokeWidth:strokeWidth}, tableElement);
	headerRect.column = column;
	headerRect.originalColor = fill;
	headerRect.setAttribute("atv:table-header-rect","true");
	var headerText = null;
	if (this.hasVML) {
		headerText = webMI.gfx.addText({x:startX+style.textOffsetX,y:startY+textOffsetY,fontFamily:fontFamily,fill:fontColor,fontSize:fontSize,text:name},tableElement);
	} else {
		headerText = webMI.gfx.addText({x:startX+width/2,y:startY+textOffsetY,fontFamily:fontFamily,fill:fontColor,fontSize:fontSize,text:name,textAnchor:"middle"},tableElement);
	}
	headerText.setAttribute("atv:table-header-text","true");

	// if there already exists an element at the position insert the new elements before it
	var overwrite = (tableElement.headerRects[column] == undefined);
	tableElement.headerRects = this._arrayInsertElement(tableElement.headerRects, column, headerRect, overwrite);
	tableElement.headerTexts = this._arrayInsertElement(tableElement.headerTexts, column, headerText, overwrite);
	// creates content cells
	if(configuration.rowCount==0) {
		configuration.tableHeight=configuration.rowHeight;
	} else if(createRows) {
		var y=startY+configuration.rowHeight;
		var x=startX;
		//draws as many cells as there are rows
		for (var row=0; row<configuration.rowCount; row++){
			// sets color for odd and even rows
			var cellStyle = this._cellStyle((row%2==0));
			this._createCell(column,row,x,y,cellStyle,false);
			y+=configuration.rowHeight;
			if(column==0) {
				configuration.tableHeight+=configuration.rowHeight;
			}
		}
	}
	configuration.columnCount++;
	configuration.tableWidth= (parseFloat(configuration.tableWidth)) + parseFloat(style.header.width);	//updates tableWidth
	this._calcHeadersOutside();
	this._drawScrollBars();
};
/**
 * Adds a row at the end of the table.
 * @param {Boolean} updateTable Indicates if the table shall be updated after the row was added.
*/
AtviseTable.prototype.addRow = function(updateTable){
	var tableElement = this.tableElement;
	var configuration = this.configuration;
	var style = this.style;
	updateTable = (updateTable != undefined) ? updateTable : true;
	if(configuration.columnCount>0) {
		// only add a row if it doesnt exceed the display size
		var calculatedDisplayHeight = (configuration.displayHeight-this.statusbar.height);
		if (this.scrollbar.barBottom!=undefined) {
			calculatedDisplayHeight-=this.configuration.scrollbarSize;
		}
		if (configuration.tableHeight + configuration.rowHeight < calculatedDisplayHeight) {
			var x=parseInt(webMI.gfx.getX(tableElement.headerRects[0]));
			var y;

			if(configuration.rowCount==0)y=configuration.rowHeight;
			else y=parseInt(webMI.gfx.getY(tableElement.cellRects[0][configuration.rowCount-1]))+configuration.rowHeight;
			var cellStyle = this._cellStyle((configuration.rowCount%2 == 0));
			//creates as many cells as there are columns
			for (var col=0;col<configuration.columnCount;col++){
				this._createCell(col,configuration.rowCount,x,y,cellStyle,false);
				x+=parseFloat(tableElement.headerObjects[col].width);
			}
			configuration.tableHeight+=configuration.rowHeight;
			configuration.rowCount++;
		}
	}
	if (updateTable) {
		this._setDataExtract();
	}
};
/**
 * Returns the current configuration Object of the table.
 * @type {Object} configurationObject
*/
AtviseTable.prototype.configuration = function() {
	return this.configuration;
};
/**
 * Returns the current headers and filtered data array of the table in CSV format.
 * @type {String} headersAndDataAsCSV
*/
AtviseTable.prototype.dataExportCSV = function(separator) {
	var csv = "";
	var separator = separator ? separator : ",";

	//header export
	if(this.tableElement.headerObjects.length > 0) {
		for(var i in this.tableElement.headerObjects) {
			if(this.tableElement.headerObjects[i].name.toString().search(separator) > -1)
				csv += "\"" + this.tableElement.headerObjects[i].name.toString().replace(/\"/, "\"\"") + "\"" + separator;
			else
				csv += this.tableElement.headerObjects[i].name.toString() + separator;
		}
		csv = csv.substr(0, csv.lastIndexOf(separator)) + "\n";
	}

	//data export
	var data = this.dataProvider().dataArray;

	if(this.dataProvider().dataFiltered.length > 0)
		data = this.dataProvider().dataFiltered;

	if(data.length > 0) {
		for(row in data) {
			for(column in data[row]) {
				if(data[row][column].text != undefined) {
					var maskedElement = (typeof this.tableElement.maskingFunctions[column] === "undefined") ?
						data[row][column].text.toString() :
						this.tableElement.maskingFunctions[column]( data[row][column].text.toString() );
					if(maskedElement.search(separator) > - 1)
						csv += "\"" + maskedElement.replace(/\"/, "\"\"") + "\"" + separator;
					else
						csv += maskedElement + separator;
				}
			}
			csv = csv.substr(0, csv.lastIndexOf(separator)) + "\n";
		}
	}
	return csv;
};
/**
 * Returns the data provider of the table.
 * @type {Object} dataProvider AtviseDataProvider
*/
AtviseTable.prototype.dataProvider = function() {
	return this.tableElement.dataProvider;
};
/**
 * Returns all header objects of the table.
 * @type {Array} headerObjects
*/
AtviseTable.prototype.headers = function() {
	return this.tableElement.headerObjects;
};
/**
 * Removes all columns of the table.
 * @param {Boolean} deleteCells Indicates if only the headers should be deleted or all content cells too.
*/
AtviseTable.prototype.removeAllColumns = function(deleteCells){
	var j=this.configuration.columnCount;
	for(var i=j;i>=1;i--){
		this.removeColumn(i,deleteCells,false,false);
	}
	// if there are no more columns, there can't exist more rows
	this.configuration.rowCount = 0;
	this.configuration.tableHeight = 0;
};
/**
 * Removes a column from the table.
 * @param {Number} colNr Column index.
 * @param {Boolean} deleteCells Indicates if only the header should be deleted or all content cells too.
 * @param {Boolean} deleteHeader Indicates if the headerObject should be deleted too, or only the rectangle and text element.
 * @param {Boolean} deleteData Indicates if the data at the column should be deleted too.
*/
AtviseTable.prototype.removeColumn = function(colNr, deleteCells, deleteHeader, deleteData) {
	var tableElement = this.tableElement;
	var configuration = this.configuration;
	var col = (colNr>0)?colNr-1:0;	// array starts with 0...
	deleteCells = (deleteCells == undefined) ? false : deleteCells;
	deleteHeader = (deleteHeader == undefined) ? false : deleteHeader;
	deleteData = (deleteData == undefined) ? false : deleteData;

	if (col<configuration.columnCount && col>-1) {
		// rearrange all cells following the column position
		if (deleteCells) {
			for (var row=(configuration.rowCount-1); row>-1; row--) {
				for (var i=(configuration.columnCount-1); i>col; i--) {
					if (tableElement.cellRects[i-1][row]) {
						var preX = parseFloat(webMI.gfx.getX(tableElement.cellRects[i-1][row]));
						webMI.gfx.setX(tableElement.cellRects[i][row],preX);
						webMI.gfx.setX(tableElement.cellTexts[i][row],preX + this.style.textOffsetX);
					}
				}
				tableElement.removeChild(tableElement.cellRects[col][row]);
				tableElement.removeChild(tableElement.cellTexts[col][row]);
			}
			tableElement.cellRects.splice(col,1);
			tableElement.cellTexts.splice(col,1);
			tableElement.cellTextContents.splice(col,1);

			// rearrange all headers following the column position
			for (var i=(tableElement.headerRects.length-1); i>col; i--) {
				if (tableElement.headerRects[i-1]) {
					var preX = parseFloat(webMI.gfx.getX(tableElement.headerRects[i-1]));
					webMI.gfx.setX(tableElement.headerRects[i],preX);
					webMI.gfx.setX(tableElement.headerTexts[i],preX+(parseFloat(webMI.gfx.getWidth(tableElement.headerRects[i])/2)));
				}
			}
		}
		configuration.tableWidth-=parseFloat(webMI.gfx.getWidth(tableElement.headerRects[col]));
		tableElement.removeChild(tableElement.headerRects[col]);
		tableElement.removeChild(tableElement.headerTexts[col]);
		tableElement.headerRects.splice(col,1);
		tableElement.headerTexts.splice(col,1);
		configuration.columnCount--;

		if(deleteData) {
			this.dataProvider().removeColumn(colNr);
		}
		if(deleteHeader) {
			tableElement.headerObjects.splice(col,1);
		}
	}
	this._calcHeadersOutside();
	// only set the table data if cells have been removed
	if (deleteCells && deleteData) {
		this._setDataExtract();
	}
};
/**
 * Removes all rows from the table.
*/
AtviseTable.prototype.removeAllRows = function(deleteData, updateTable) {
	var deleteData = (deleteData == undefined) ? false : deleteData;
	updateTable = (updateTable == undefined) ? false : updateTable;
	var j=this.configuration.rowCount;
	for(var i=j;i>=1;i--){
		this.removeRow(i,deleteData,false);
	}
	if (updateTable) {
		this._setDataExtract();
	}
};
/**
 * Removes a row from the table.
 * @param {Number} rowNr Row index.
 * @param {Boolean} deleteData Indicates if the data at the row should be deleted too.
 * @param {Boolean} [updateTable] Indicates if the table should be updated after removing the row.
*/
AtviseTable.prototype.removeRow = function(rowNr,deleteData,updateTable) {
	var tableElement = this.tableElement;
	var configuration = this.configuration;
	var updateTable = (updateTable != undefined) ? updateTable : true;
	if (rowNr<=configuration.rowCount && rowNr>0) {	//only if rowNr is valid
		if(deleteData) {
			this.dataProvider().removeRow(rowNr, updateTable);
		}
		for (var col=0;col<configuration.columnCount;col++){	//removes as many cells from the row as there are columns
			tableElement.removeChild(tableElement.cellRects[col][configuration.rowCount-1]);
			tableElement.removeChild(tableElement.cellTexts[col][configuration.rowCount-1]);
			tableElement.cellRects[col].splice(configuration.rowCount-1,1);
			tableElement.cellTexts[col].splice(configuration.rowCount-1,1);
		}
		configuration.rowCount--;					//decrements total number of rows
		configuration.tableHeight-=configuration.rowHeight;		//updates the table height
	}
	if (updateTable) {
		this._setDataExtract();
	}
};
/**
 * Returns the selected column number of the table (human format).
 * @type {Number} colNr
*/
AtviseTable.prototype.selectedColumn = function() {
	return (this.tableElement.selectedColumn>-1)?this.tableElement.selectedColumn+1:undefined;
};
/**
 * Returns the selected data of the table.
 * @type {Array} data
*/
AtviseTable.prototype.selectedData = function() {
	function unique(arrayInstance) {
		var r = new Array();
		o:for(var i = 0, n = arrayInstance.length; i < n; i++) {
			for(var x = 0, y = r.length; x < y; x++) {
				if(r[x]==arrayInstance[i]) {
					continue o;
				}
			}
			r[r.length] = arrayInstance[i];
		}
		return r;
	}
	var data = [];
	var dataRow = this.dataProvider().dataRow((this.tableElement.selectedRow+1));
	var dataColumn = this.dataProvider().dataColumn((this.tableElement.selectedColumn+1));
	for (var i in dataRow) {
		data.push(dataRow[i]);
	}
	for (var i in dataColumn) {
		data.push(dataColumn[i]);
	}
	return unique(data);
};
/**
 * Returns the selected data column of the current data of the table.
 * @type {Array} dataColumn
*/
AtviseTable.prototype.selectedDataColumn = function() {
	return this.dataProvider().dataColumn((this.tableElement.selectedColumn+1));
};
/**
 * Returns the selected data row of the current data of the table.
 * @type {Array} dataRow
*/
AtviseTable.prototype.selectedDataRow = function() {
	return this.dataProvider().dataRow((this.tableElement.selectedRow+1));
};
/**
 * Returns the selected row number of the table (human format).
 * @type {Number} rowNr
*/
AtviseTable.prototype.selectedRow = function() {
	return (this.tableElement.selectedRow>-1)?this.tableElement.selectedRow+1+this.tableElement.scrollRowOffset:undefined;
};
/**
 * Sets the configuration of the table.
 * @param {Object} newConfiguration Configuration object.
*/
AtviseTable.prototype.setConfiguration = function(newConfiguration) {
	var selectRowOld = this.configuration.selectRow;
	var selectColumnOld = this.configuration.selectColumn;
	this.configuration = this._setProperties(this.configuration, newConfiguration, true);
	this.scrollbar.buttonHeight=this.configuration.scrollbarSize;
	this.scrollbar.buttonWidth=this.configuration.scrollbarSize;
	this.scrollbar.barBottomHeight=this.configuration.scrollbarSize;
	this.scrollbar.barSideWidth=this.configuration.scrollbarSize;
	this.scrollbar.barGripHeight=this.configuration.scrollbarSize;
	this.scrollbar.barGripWidth=this.configuration.scrollbarSize;
	if (((selectRowOld != this.configuration.selectRow) && this.configuration.selectRow) || ((selectColumnOld != this.configuration.selectColumn) && this.configuration.selectColumn)) {
		for (var i=0; i<this.configuration.columnCount; i++) {
			for (var j=0; j<this.configuration.rowCount; j++) {
				webMI.addEvent(this.tableElement.cellRects[i][j],"click",this._associateObjWithEvent(this,"_selectCell",[this.tableElement.cellRects[i][j]]));
				webMI.addEvent(this.tableElement.cellTexts[i][j],"click",this._associateObjWithEvent(this,"_selectCell",[this.tableElement.cellRects[i][j]]));
			}
		}
	}
	this.statusbar.height = this.configuration.rowHeight;
	if (!this.configuration.drawStatusBar) {
		this._undrawStatusBar();
	}
};
/**
 * Attaches an data provider to the table.
 * @param {Object} dataProvider A data provider of type AtviseDataProvider
*/
AtviseTable.prototype.setDataProvider = function(source, config) {
	if (config == undefined) {
		var statusbarHeight = (this.configuration.drawStatusBar)?this.statusbar.height:0;
		var rows = Math.floor((this.configuration.displayHeight-statusbarHeight-this.configuration.rowHeight) / this.configuration.rowHeight);
		config = {maxResults: rows};
	}
	config.sortedByColumn = this.configuration.sortedByColumn;
	config.sortingUp = this.configuration.sortingUp;
	this.tableElement.dataProvider = new AtviseDataProvider(source, config);
	this.tableElement.dataProvider.subscribe(this._associateObjWithEvent(this,"_setDataExtract",[]));
};
/**
 * Sets/Adds a header object to the table.
 * @param {Object} header Header object.
 * @param {Number} column Column index.
 * @param {Boolean} overwrite Indicates if the the header shall be overwritten.
*/
AtviseTable.prototype.setHeader = function(header, column, overwrite) {
	// decrement, because array index is starting with 0
	column--;
	var tableElement = this.tableElement;
	var configuration = this.configuration;
	var style = this.style;

	var headerRects = tableElement.headerRects;
	var headerTexts = tableElement.headerTexts;
	this._addHeader(header, column, overwrite);
	var headerObjects = tableElement.headerObjects;

	var insert = (column < configuration.columnCount && !overwrite);

	// check if there are more/less columns than headers
	if (headerObjects.length > configuration.columnCount && configuration.autoResize) {
		for (var i=(configuration.columnCount+1); i<(headerObjects.length+1); i++) {
			this.addColumn(i);
		}
	} else if (headerObjects.length < configuration.columnCount && configuration.autoResize ) {
		for (var i=headerObjects.length; i<configuration.columnCount; i++) {
			this.removeColumn(i, true, true, false);
		}
	}
	// update the column according to the headerObject data
	if (column < configuration.columnCount) {
		this._updateHeader(column);
	}
	// if inserting, also reset all headers following the inserted header
	if (insert) {
		for (var i=(column+1); i<configuration.columnCount; i++) {
			this._updateHeader(i);
		}
	}

	var calculatedTableWidth = 0;
	for (var i=0; i<tableElement.headerRects.length; i++) {
		calculatedTableWidth += parseFloat(webMI.gfx.getWidth(tableElement.headerRects[i]));
	}
	configuration.tableWidth = calculatedTableWidth;
	this._calcHeadersOutside();
	this._drawScrollBars();
	if (this.configuration.drawStatusBar) {
		this._drawStatusBar();
	}
	this._drawSortingArrow();
};
/**
 * Sets/Adds an array of header objects to the table.
 * @param {Boolean} overwrite Indicates if the header objects shall be overwritten.
*/
AtviseTable.prototype.setHeaders = function(headers) {
	var overwrite = (arguments[1])?arguments[1]:true;
	if (overwrite && this.configuration.autoResize) {
		this.removeAllColumns(true);
	}
	if (headers.length < this.configuration.columnCount) {
		for (var i=this.configuration.columnCount; i>headers.length; i--) {
			this.removeColumn(i, true, true, false);
		}
	}
	for (var i=0; i<(headers.length); i++) {
		var column = i+1;
		this.setHeader(headers[i], column, overwrite);
	}
};
/**
 * Sets/Adds an array of masking functions to the table.
 * @param {Array}: maskingFunctions: [{columnNumber: 1, <OR columnName: columnName,> mask: function(){...}},...]
*/
AtviseTable.prototype.setMaskingFunctions = function(maskingFunctions){
	this.tableElement.maskingFunctions = new Array(this.tableElement.headerTexts.length);

	for (var i = 0; i < maskingFunctions.length; i++){
		var mask;
		if (maskingFunctions[i].hasOwnProperty("maskFunction")){
			mask = maskingFunctions[i].maskFunction;
		} else if (maskingFunctions[i].maskName == "dateMS"){
			mask = function(timestamp){
				if (timestamp == null || timestamp == "")
					return "";
				var date = new Date(parseInt(timestamp, 10));
				return webMI.sprintf("%d-%02d-%02d %02d:%02d:%02d.%03d", date.getFullYear(), date.getMonth()+1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
			};
		} else if (maskingFunctions[i].maskName == "date"){
			mask = function(timestamp){
				if (timestamp == null || timestamp == "")
					return "";
				var date = new Date(parseInt(timestamp, 10));
				return webMI.sprintf("%d-%02d-%02d %02d:%02d:%02d", date.getFullYear(), date.getMonth()+1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds());
			};
		} else
			mask = function(){return ""};

		if (maskingFunctions[i].hasOwnProperty("columnName")){
			var found = false;
			for (var j = 0; j < this.configuration.columnCount; j++){
				if (this.tableElement.headerObjects[j].name == maskingFunctions[i]["columnName"]){
					this.tableElement.maskingFunctions[j] = mask;
					found = true;
				}
			}
			if (!found)
				console.warn("Table: Please make sure that the column named: " + maskingFunctions[i]["columnName"] + " exists.");
		} else if (maskingFunctions[i].columnNumber < this.tableElement.maskingFunctions.length)
			this.tableElement.maskingFunctions[maskingFunctions[i].columnNumber] = maskingFunctions[i].mask;
		else if (maskingFunctions[i].columnNumber >= this.tableElement.maskingFunctions.length)
			console.warn("Table: Please note, the column number of the masking function is larger than the amount of existing columns.");
	}
};
/**
 * Sets the scrollbar object of the table.
 * @param {Object} scrollbar Scrollbar object.
*/
AtviseTable.prototype.setScrollbar = function(scrollbar) {
	this._setProperties(this.scrollbar, scrollbar, true);
};
/**
 * Sets the statusbar object of the table.
 * @param {Object} statusbar Statusbar object.
*/
AtviseTable.prototype.setStatusbar = function(statusbar) {
	this._setProperties(this.statusbar, statusbar, true);
	if (this.configuration.drawStatusBar) {
		this._drawStatusBar();
	}
};
/**
 * Sets the style object of the table.
 * @param {Object} style Style object.
*/
AtviseTable.prototype.setStyle = function(style) {
	this._setProperties(this.style, style, true);
};
/**
 * Sets the style object for even rows of the table.
 * @param {Object} style Style object.
*/
AtviseTable.prototype.setStyleEven = function(style) {
	this._setProperties(this.styleEven, style, true);
	var data = this.dataProvider().data;
	if (data.length > 0) {
		for (var i=0; i<data.length; i++) {
			if (i%2==0) {
				this.dataProvider().setRowStyle((i+1), this.styleEven);
			}
		}
	}
};
/**
 * Sets the style object for odd rows of the table.
 * @param {Object} style Style object.
*/
AtviseTable.prototype.setStyleOdd = function(style) {
	this._setProperties(this.styleOdd, style, true);
	var data = this.dataProvider().data;
	if (data.length > 0) {
		for (var i=0; i<data.length; i++) {
			if (i%2==0) {
				this.dataProvider().setRowStyle((i+1), this.styleOdd);
			}
		}
	}
};

/*  ***********************************************************
	********** atvise table widget PRIVATE FUNCTIONS **********
	*********************************************************** */

// TODO: missing documentation
AtviseTable.prototype._addHeader = function(headerObject) {
	if (!headerObject) return;
	var headerObjects = this.tableElement.headerObjects;
	headerObject = this._setProperties(headerObject, {name:"Header_"+headerObjects.length,width:"140",fill:"#868a86",highlight: {fill: "#C0C0C0", selected:"#877DDF"},fontFamily:"Arial",fontSize:"16",fontColor:"#000000", sortable:true, resizable:true, cursor: "pointer"}, false);
	if (headerObjects.length > 0) {
		var position = headerObjects.length;
		var overwrite = false;
		if(arguments.length>1) {
			if (typeof arguments[1] == "number") {
				position = arguments[1];
			} else {
				return;
			}
			if (typeof arguments[2] == "boolean") {
				overwrite = arguments[2];
			} else {
				return;
			}
		}
		// position lies within the existing array of header objects
		headerObjects = this._arrayInsertElement(headerObjects, position, headerObject, overwrite);
	} else {
		headerObjects.push(headerObject);
	}
	this.tableElement.headerObjects = headerObjects;
};

// TODO: missing documentation
AtviseTable.prototype._arrayInsertElement = function(arrayInstance, position, newElement, overwrite) {
	if (arrayInstance.length > 0) {
		if (overwrite) {
			arrayInstance[position] = newElement;
		} else {
			var a = arrayInstance.slice();
			var b = a.splice(position,a.length);
			a[position] = newElement;
			arrayInstance = a.concat(b);
		}
	} else {
		arrayInstance.push(newElement);
	}
	return arrayInstance;
};
// TODO: missing documentation
AtviseTable.prototype._arrayRemoveElement = function(arrayInstance, position) {
	if (arrayInstance.length > 0) {
		if (arrayInstance[position] != undefined) {
			arrayInstance.splice(position, 1);
		}
	}
	return arrayInstance;
};
// TODO: missing documentation
// associates an object with a method (usually called to access the atviseTable with "this" from an child element - e.g. header mousedown)
AtviseTable.prototype._associateObjWithEvent = function(obj, methodName, myArguments){
    return (function(e){
        e = e||window.event;
        return obj[methodName](e, myArguments);
    });
};
// TODO: missing documentation
AtviseTable.prototype._calcHeadersOutside = function() {
	var headersOutside = 0;
	var visible = true;
	var firstOutside = -1;

	for (var i=0; i<this.tableElement.headerRects.length; i++) {
		var headerX = parseFloat(webMI.gfx.getX(this.tableElement.headerRects[i]));
		var headerW = parseFloat(webMI.gfx.getWidth(this.tableElement.headerRects[i]));

		if((headerX+headerW)>this.configuration.displayWidth) {
			if (headersOutside == 0) {
				firstOutside = i;
			}
			headersOutside++;
			visible = false;
		}
		webMI.gfx.setVisible(this.tableElement.headerRects[i],visible);
		webMI.gfx.setVisible(this.tableElement.headerTexts[i],visible);
	}
	if (firstOutside > -1) {
		for (var i=firstOutside; i<this.tableElement.cellRects.length; i++) {
			for (var j=0; j<this.tableElement.cellRects[i].length; j++) {
				if (this.tableElement.cellRects[i][j] != undefined) {
					webMI.gfx.setVisible(this.tableElement.cellRects[i][j], visible);
				}
			}
		}
	}

	this.tableElement.firstHeaderOutside = firstOutside;
	this.tableElement.headersOutside = headersOutside;
};
// TODO: missing documentation
AtviseTable.prototype._cellStyle = function(even) {
	return (even)?this.styleEven:this.styleOdd;
};
// TODO: missing documentation
AtviseTable.prototype._checkArray = function(arrayToCheck, idx1, idx2) {
	if (arrayToCheck == undefined) {
		arrayToCheck = [];
	}
	if (idx1 != undefined) {
		if (arrayToCheck[idx1] == undefined) {
			arrayToCheck[idx1] = [];
		}
	}
	if (idx2 != undefined) {
		if (arrayToCheck[idx1][idx2] == undefined) {
			arrayToCheck[idx1][idx2] = [];
		}
	}
};
// TODO: missing documentation
AtviseTable.prototype._createCell = function(col,row,x,y,cellStyle){
	var tableElement = this.tableElement;
	var configuration = this.configuration;
	var style = this.style;

	var cellRects = tableElement.cellRects;
	var cellTexts = tableElement.cellTexts;
	var cellTextContents = tableElement.cellTextContents;
	var textOffsetY = configuration.rowHeight - ((configuration.rowHeight/2)-(style.fontSize/2)) - 2;

	this._checkArray(cellRects,col,row);
	this._checkArray(cellTexts,col,row);
	this._checkArray(cellTextContents,col,row);

	//default text and style of the cell
	var fill = cellStyle.fill;
	var fontFamily = cellStyle.fontFamily;
	var fontSize = cellStyle.fontSize;
	var fontColor = cellStyle.fontColor;
	var stroke = cellStyle.stroke;
	var strokeWidth = cellStyle.strokeWidth;
	var dataObj = (this.dataProvider() != null) ? this.dataProvider().dataObject((row+1), (col+1)) : undefined;
	if (dataObj != undefined) {
		cellTextContents[col][row] = dataObj.text;
		if (dataObj.fill!=undefined) {
			fill = dataObj.fill;
		}
		if (dataObj.fontColor!=undefined) {
			fontColor = dataObj.fontColor;
		}
		if (dataObj.fontSize!=undefined) {
			fontSize = dataObj.fontSize;
		}
		if (dataObj.fontFamily!=undefined) {
			fontFamily = dataObj.fontFamily;
		}
		if (dataObj.stroke!=undefined) {
			stroke = dataObj.stroke;
		}
		if (dataObj.strokeWidth!=undefined) {
			strokeWidth = dataObj.strokeWidth;
		}
	} else {
		cellTextContents[col][row]="";
	}

	var visible = true;
	if (this.tableElement.firstHeaderOutside > -1 && col >= this.tableElement.firstHeaderOutside) {
		visible = false;
	}

	// creates cell rectangle
	cellRects[col][row]= webMI.gfx.addRect({width:webMI.gfx.getWidth(tableElement.headerRects[col]),height:configuration.rowHeight,x:x,y:y,fill:fill,stroke:stroke,strokeWidth:strokeWidth,visible:visible},tableElement);
	cellRects[col][row].column=col;
	cellRects[col][row].row=row;
	cellRects[col][row].originalColor=fill;
	cellRects[col][row].setAttribute("atv:table-body-rect","true");
	var maskedElement = (typeof this.tableElement.maskingFunctions[col] === "undefined") ?
		this.tableElement.cellTextContents[col][row] :
		this.tableElement.maskingFunctions[col]( this.tableElement.cellTextContents[col][row] );
	cellTexts[col][row] = webMI.gfx.addText({x:x+style.textOffsetX,y:y+textOffsetY,fontFamily:fontFamily,fill:fontColor,fontSize:fontSize,text:maskedElement,visible:visible},tableElement);
	cellTexts[col][row].column=col;
	cellTexts[col][row].row=row;
	cellTexts[col][row].setAttribute("atv:table-body-text","true");

	if (configuration.highlightCells || configuration.selectRow || configuration.selectColumn) {
		webMI.addEvent(cellRects[col][row],"mouseover",this._associateObjWithEvent(this,"_highlightCell",[cellRects[col][row], true]));
		webMI.addEvent(cellRects[col][row],"mouseout",this._associateObjWithEvent(this,"_highlightCell",[cellRects[col][row], false]));
		webMI.addEvent(cellTexts[col][row],"mouseover",this._associateObjWithEvent(this,"_highlightCell",[cellRects[col][row], true]));
		webMI.addEvent(cellTexts[col][row],"mouseout",this._associateObjWithEvent(this,"_highlightCell",[cellRects[col][row], false]));
		if (configuration.selectRow || configuration.selectColumn) {
			webMI.addEvent(cellRects[col][row],"click",this._associateObjWithEvent(this,"_selectCell",[cellRects[col][row]]));
			webMI.addEvent(cellTexts[col][row],"click",this._associateObjWithEvent(this,"_selectCell",[cellRects[col][row]]));
		}
	}
};
// TODO: missing documentation
AtviseTable.prototype._createPredefinedTable = function() {
	var oldAutoResize = this.configuration.autoResize;
	this.setConfiguration({autoResize:true});
	var headerRects = [];
	var headerTexts = [];
	var rects = [];
	var texts = [];
	var data = [];
	var childsToRemove = [];

	for (var i in this.tableElement.childNodes) {
		var childEle = this.tableElement.childNodes[i];
		if (childEle.attributes != undefined) {
			if (this.hasSVG && childEle.getAttributeNS("http://webmi.atvise.com/2007/svgext","table-header-rect") == "true") {
				headerRects.push(childEle);
			} else if (this.hasVML && childEle.getAttribute("atv:table-header-rect") == "true") {
				headerRects.push(childEle);
			} else if (this.hasSVG && childEle.getAttributeNS("http://webmi.atvise.com/2007/svgext","table-header-text") == "true") {
				headerTexts.push(childEle);
			} else if (this.hasVML && childEle.getAttribute("atv:table-header-text") == "true") {
				headerTexts.push(childEle);
			} else if (this.hasSVG && childEle.getAttributeNS("http://webmi.atvise.com/2007/svgext","table-body-rect") == "true") {
				rects.push(childEle);
			} else if (this.hasVML && childEle.getAttribute("atv:table-body-rect") == "true") {
				rects.push(childEle);
			} else if (this.hasSVG && childEle.getAttributeNS("http://webmi.atvise.com/2007/svgext","table-body-text") == "true") {
				texts.push(childEle);
			} else if (this.hasVML && childEle.getAttribute("atv:table-body-text") == "true") {
				texts.push(childEle);
			}  else {
				childsToRemove.push(childEle);
			}
		}
	}
	// remove all non-table childs

	var i = childsToRemove.length-1;
	while (i > -1) {
		this.tableElement.removeChild(childsToRemove[i]);
		i--;
	}
	if (headerRects.length < 1) {
		// there were no child elements defined for creating a table
		this.setConfiguration({autoResize:oldAutoResize});
		this._createTable();
		return;
	}
	// read headers
	var startX = 0;
	for (var i=0; i<headerRects.length; i++) {
		var name = webMI.gfx.getText(headerTexts[i]);
		var fontColor = webMI.gfx.getFill(headerTexts[i]);
		var fontSize = webMI.gfx.getFontSize(headerTexts[i]);
		var fontFamily = webMI.gfx.getFontFamily(headerTexts[i]);
		var width = Math.floor(parseFloat(webMI.gfx.getWidth(headerRects[i])));
		var fill = webMI.gfx.getFill(headerRects[i]);
		var stroke = webMI.gfx.getStroke(headerRects[i]);
		var strokeWidth = webMI.gfx.getStrokeWidth(headerRects[i]);
		this._addHeader({name: name, width: width, fill: fill, fontColor: fontColor, fontSize:fontSize, fontFamily:fontFamily, stroke:stroke, strokeWidth:strokeWidth, sortable: true, resizable: true, eventList: []});
		this._checkArray(this.tableElement.headerRects,i);
		this._checkArray(this.tableElement.headerTexts,i);
		this.tableElement.headerRects[i] = headerRects[i];
		this.tableElement.headerRects[i].column = i;
		this.tableElement.headerRects[i].originalColor = fill;
		this.tableElement.headerTexts[i] = headerTexts[i];
		webMI.gfx.setX(this.tableElement.headerRects[i], startX);
		webMI.gfx.setX(this.tableElement.headerTexts[i], startX + (width/2));
		fontSize = (fontSize == undefined)?this.style.header.fontSize:fontSize;
		var textOffsetY = this.configuration.rowHeight - ((this.configuration.rowHeight/2)-(fontSize/2)) - 2;
		webMI.gfx.setY(this.tableElement.headerRects[i],0);
		webMI.gfx.setY(this.tableElement.headerTexts[i],0+textOffsetY);
		this.tableElement.headerTexts[i].setAttribute("text-anchor","middle");
		webMI.gfx.setWidth(this.tableElement.headerRects[i], width);
		webMI.gfx.setHeight(this.tableElement.headerRects[i], this.configuration.rowHeight);
		startX += width;
		this.configuration.tableWidth += width;
		this._updateHeader(i);
	}

	this.setConfiguration({columnCount:this.tableElement.headerRects.length});
	// read data and cells
	if (rects.length == texts.length) {
		var idx = 0;
		var width = 0;
		var startX = 0;
		var startY = this.configuration.rowHeight;
		for (var i=0; i<rects.length; i++) {
			if (i != 0 && (i % this.configuration.columnCount) == 0) {
				this.configuration.rowCount++;
				startY += this.configuration.rowHeight;
				idx = 0;
				startX = 0;
			}
			this._checkArray(data,this.configuration.rowCount,idx);
			this._checkArray(this.tableElement.cellRects,idx,this.configuration.rowCount);
			this._checkArray(this.tableElement.cellTexts,idx,this.configuration.rowCount);
			this._checkArray(this.tableElement.cellTextContents,idx,this.configuration.rowCount);

			var text = webMI.gfx.getText(texts[i]);
			var fill = webMI.gfx.getFill(rects[i]);
			var fontColor = webMI.gfx.getFill(texts[i]);
			var fontSize = webMI.gfx.getFontSize(texts[i]);
			var fontFamily = webMI.gfx.getFontFamily(texts[i]);
			var stroke = webMI.gfx.getStroke(rects[i]);
			var strokeWidth = webMI.gfx.getStrokeWidth(rects[i]);

			data[this.configuration.rowCount][idx] = {text:text, fill:fill, fontColor: fontColor, fontSize:fontSize, fontFamily:fontFamily, stroke: stroke, strokeWidth:strokeWidth};
			this.tableElement.cellRects[idx][this.configuration.rowCount] = rects[i];
			this.tableElement.cellTexts[idx][this.configuration.rowCount] = texts[i];
			this.tableElement.cellTextContents[idx][this.configuration.rowCount] = text;

			this.tableElement.cellRects[idx][this.configuration.rowCount].column=idx;
			this.tableElement.cellRects[idx][this.configuration.rowCount].row=this.configuration.rowCount;
			this.tableElement.cellRects[idx][this.configuration.rowCount].originalColor=fill;

			if (this.configuration.highlightCells || this.configuration.selectRow || this.configuration.selectColumn) {
				webMI.addEvent(this.tableElement.cellRects[idx][this.configuration.rowCount],"mouseover",this._associateObjWithEvent(this,"_highlightCell",[this.tableElement.cellRects[idx][this.configuration.rowCount], true]));
				webMI.addEvent(this.tableElement.cellRects[idx][this.configuration.rowCount],"mouseout",this._associateObjWithEvent(this,"_highlightCell",[this.tableElement.cellRects[idx][this.configuration.rowCount], false]));
				webMI.addEvent(this.tableElement.cellTexts[idx][this.configuration.rowCount],"mouseover",this._associateObjWithEvent(this,"_highlightCell",[this.tableElement.cellRects[idx][this.configuration.rowCount], true]));
				webMI.addEvent(this.tableElement.cellTexts[idx][this.configuration.rowCount],"mouseout",this._associateObjWithEvent(this,"_highlightCell",[this.tableElement.cellRects[idx][this.configuration.rowCount], false]));
				if (this.configuration.selectRow || this.configuration.selectColumn) {
					webMI.addEvent(cellRects[col][row],"click",this._associateObjWithEvent(this,"_selectCell",[cellRects[col][row]]));
					webMI.addEvent(cellTexts[col][row],"click",this._associateObjWithEvent(this,"_selectCell",[cellRects[col][row]]));
				}
			}

			var width = parseFloat(this.tableElement.headerObjects[idx].width);
			webMI.gfx.setX(this.tableElement.cellRects[idx][this.configuration.rowCount], startX);
			webMI.gfx.setX(this.tableElement.cellTexts[idx][this.configuration.rowCount], startX + this.style.textOffsetX);
			webMI.gfx.setWidth(this.tableElement.cellRects[idx][this.configuration.rowCount],width);
			fontSize = (fontSize == undefined)?this.style.fontSize:fontSize;
			var textOffsetY = this.configuration.rowHeight - ((this.configuration.rowHeight/2)-(fontSize/2)) - 2;
			webMI.gfx.setY(this.tableElement.cellRects[idx][this.configuration.rowCount], startY);
			webMI.gfx.setY(this.tableElement.cellTexts[idx][this.configuration.rowCount], startY + textOffsetY);
			startX += width;
			idx++;
		}
		this.configuration.rowCount++;
		this.setDataProvider({data: data});
	}
	this.setConfiguration({autoResize:false});
};
// TODO: missing documentation
AtviseTable.prototype._createTable = function() {
	// if the tableElement has no predefined cells then create as many as there is space
	var cols = Math.floor(((this.configuration.displayWidth-this.configuration.scrollbarSize) / this.style.header.width));
	var statusbarHeight = (this.configuration.drawStatusBar)?this.statusbar.height:0;
	var rows = Math.floor((this.configuration.displayHeight-statusbarHeight-this.configuration.rowHeight) / this.configuration.rowHeight);
	this.setConfiguration({rowCount: rows});
	for (var i=1; i<(cols+1); i++) {
		this.addColumn(i);
	}
};
// TODO: missing documentation
AtviseTable.prototype._drag = function(e, arguments) {
	var moveX = arguments[0];
	var moveY = arguments[1];

	//var origX = element.offsetLeft, origY = element.offsetTop;
	var deltaX = 10;
	var deltaY = 10; //startX - origX, deltaY = startY - origY;

	if (document.addEventListener) {  // DOM Level 2 event model
        document.addEventListener("mousemove", moveHandler, true);
        document.addEventListener("mouseup", upHandler, true);
    }
    else if (document.attachEvent) {  // IE 5+ Event Model
        element.setCapture();
        element.attachEvent("onmousemove", moveHandler);
        element.attachEvent("onmouseup", upHandler);
        // Treat loss of mouse capture as a mouseup event
        element.attachEvent("onlosecapture", upHandler);
    }
    else {  // IE 4 Event Model
        var oldmovehandler = document.onmousemove; // used by upHandler()
        var olduphandler = document.onmouseup;
        document.onmousemove = moveHandler;
        document.onmouseup = upHandler;
    }

	if(e.stopPropagation) e.stopPropagation();
	else e.cancelBubble = true;

	if(e.preventDefault) e.preventDefault();
	else e.returnValue = false;

	function moveHandler(e) {
		if (!e) e = window.event;
		var startX = parseFloat(webMI.gfx.getX(element));
		var startY = parseFloat(webMI.gfx.getY(element));
		//cnsole.log(startX + "    " + startY);
		if(moveX) {
			webMI.gfx.setX(element, (startX + deltaX));
		}
		if(moveY) {
			webMI.gfx.setY(element, (startY + deltaY));
		}

		if(e.stopPropagation) e.stopPropagation();
		else e.cancelBubble = true;
	}

	function upHandler(e) {
		if (!e) e = window.event;
		if (document.removeEventListener) {  // DOM event model
            document.removeEventListener("mouseup", upHandler, true);
            document.removeEventListener("mousemove", moveHandler, true);
        }
        else if (document.detachEvent) {  // IE 5+ Event Model
            element.detachEvent("onlosecapture", upHandler);
            element.detachEvent("onmouseup", upHandler);
            element.detachEvent("onmousemove", moveHandler);
            element.releaseCapture();
        }
        else {  // IE 4 Event Model
            document.onmouseup = olduphandler;
            document.onmousemove = oldmovehandler;
        }
		if(e.stopPropagation) e.stopPropagation();
		else e.cancelBubble = true;
	}
};
// TODO: missing documentation
AtviseTable.prototype._drawScrollBars = function() {
	var tableElement = this.tableElement;
	var configuration = this.configuration;
	var lastItemIndex = (this.dataProvider() != null) ? this.dataProvider().lastItemIndex() : null;
	this._undrawScrollBars();
	if (tableElement && lastItemIndex != null && configuration.columnCount > 0 && configuration.rowCount > 0) {
		var scrollbar = this.scrollbar;
		var statusbar = this.statusbar;
		var maxRows = Math.floor((this.configuration.displayHeight-statusbar.height-this.configuration.rowHeight) / this.configuration.rowHeight);
		var drawSide = (lastItemIndex+2) > maxRows;
		var maxOffset = (lastItemIndex+2) - configuration.rowCount;
		if (tableElement.scrollRowOffset > maxOffset && maxOffset > -1) {
			tableElement.scrollRowOffset = maxOffset;
		}
		var drawBottom = configuration.tableWidth > configuration.displayWidth;
		var xBottom=parseInt(webMI.gfx.getX(tableElement.cellRects[tableElement.scrollColOffset][tableElement.cellRects[0].length-1]));
		var yBottom=0;

		if(configuration.rowCount==0) {
			yBottom=configuration.rowHeight;
		} else {
			yBottom=parseInt(webMI.gfx.getY(tableElement.cellRects[0][tableElement.cellRects[0].length-1]))+configuration.rowHeight;
			// scrollbar size plus table height exceed the displayHeight
			if ((yBottom + configuration.rowHeight + configuration.scrollbarSize) > configuration.displayHeight) {
				this.removeRow(tableElement.cellRects[0].length-1,false,false);
			}
		}
		var xSide=configuration.tableWidth;
		var ySide=parseInt(webMI.gfx.getY(tableElement.headerRects[0]));

		if (this.tableElement.headersOutside > 0) {
			for (var i=this.tableElement.firstHeaderOutside; i<this.configuration.columnCount; i++) {
				if (this.tableElement.headerRects[i] != undefined) {
					xSide -= parseFloat(webMI.gfx.getWidth(this.tableElement.headerRects[i]));
				}
			}
		}

		if (drawBottom && xSide > configuration.displayWidth) {
			xSide = configuration.displayWidth - ((drawSide)?scrollbar.barSideWidth:0);
		} else if(drawSide) {
			xSide = (configuration.tableWidth+scrollbar.barSideWidth>configuration.displayWidth)?configuration.displayWidth-scrollbar.barSideWidth:configuration.tableWidth;
		}
		if(drawSide && drawBottom) {
			scrollbar.barDecoRect=webMI.gfx.addRect({width:scrollbar.buttonWidth,height:scrollbar.buttonHeight,x:xSide,y:yBottom,fill:"#eeeeee",stroke:"#000000",strokeWidth:1}, tableElement);
		}
		// coordinates for arrows
		var x1,x2,x3,x4,y1,y2,y3,y4;

		//barBottom
		if(drawBottom) {
			scrollbar.barBottom=webMI.gfx.addRect({width:xSide,height:scrollbar.barBottomHeight,x:xBottom,y:yBottom,fill:scrollbar.barFill,stroke:scrollbar.barStroke,strokeWidth:scrollbar.barStrokeWidth}, tableElement);
			scrollbar.buttonLeft=webMI.gfx.addRect({width:scrollbar.buttonWidth,height:scrollbar.buttonHeight,x:xBottom,y:yBottom,fill:scrollbar.buttonFill,stroke:scrollbar.buttonStroke,strokeWidth:scrollbar.buttonStrokeWidth}, tableElement);
			scrollbar.buttonRight=webMI.gfx.addRect({width:scrollbar.buttonWidth,height:scrollbar.buttonHeight,x:xSide-scrollbar.buttonWidth,y:yBottom,fill:scrollbar.buttonFill,stroke:scrollbar.buttonStroke,strokeWidth:scrollbar.buttonStrokeWidth}, tableElement);
			var overflowX = configuration.tableWidth - configuration.displayWidth;
			var sliderWidth =  xSide-(2*scrollbar.buttonWidth);
			scrollbar.barGripWidth = sliderWidth - overflowX;
			scrollbar.barBottomGrip=webMI.gfx.addRect({width:scrollbar.barGripWidth,height:scrollbar.barBottomHeight,x:xBottom+scrollbar.buttonWidth,y:yBottom,fill:scrollbar.barGripFill,stroke:scrollbar.buttonStroke,strokeWidth:scrollbar.buttonStrokeWidth}, tableElement);
			var gripXoffset = ((sliderWidth-scrollbar.barGripWidth)/tableElement.headersOutside)*tableElement.scrollColOffset;
			webMI.gfx.setMoveX(scrollbar.barBottomGrip,gripXoffset);
			webMI.addEvent(scrollbar.buttonLeft,"click",this._associateObjWithEvent(this,"_scroll",["left"]));
			webMI.addEvent(scrollbar.buttonRight,"click",this._associateObjWithEvent(this,"_scroll",["right"]));
			/* TODO: activate _drag Event when _drag function works
				webMI.addEvent(scrollbar.barBottomGrip,"mousedown",function(e) {
				_drag(e, scrollbar.barBottomGrip, [true,false]);
			});*/
			//draws arrow for buttonRight
			x1=parseInt(webMI.gfx.getX(scrollbar.buttonRight))+scrollbar.buttonWidth/3;
			y1=parseInt(webMI.gfx.getY(scrollbar.buttonRight))+scrollbar.buttonHeight/3;
			x2=x1+scrollbar.buttonWidth/3;
			y2=y1+scrollbar.buttonHeight/6;
			x3=x1;
			y3=y2+scrollbar.buttonHeight/6;
			x4=x1;
			y4=y1;
			scrollbar.buttonRightArrow=webMI.gfx.addPolyline({fill:"#000000",points:[{x:x1,y:y1},{x:x2,y:y2},{x:x3,y:y3},{x:x4,y:y4}],stroke:"#000000",strokeWidth:0},tableElement);
			//draws arrow for buttonLeft
			x1=parseInt(webMI.gfx.getX(scrollbar.buttonLeft))+2*scrollbar.buttonWidth/3;
			y1=parseInt(webMI.gfx.getY(scrollbar.buttonLeft))+scrollbar.buttonHeight/3;
			x2=x1;
			y2=y1+scrollbar.buttonHeight/3;
			x3=x1-scrollbar.buttonWidth/3;
			y3=y2-scrollbar.buttonHeight/6;
			x4=x1;
			y4=y1;
			scrollbar.buttonLeftArrow=webMI.gfx.addPolyline({fill:"#000000",points:[{x:x1,y:y1},{x:x2,y:y2},{x:x3,y:y3},{x:x4,y:y4}],stroke:"#000000",strokeWidth:0},tableElement);
			//events for buttons
			webMI.addEvent(scrollbar.buttonRightArrow,"click", this._associateObjWithEvent(this,"_scroll",["right"]));
			webMI.addEvent(scrollbar.buttonLeftArrow,"click", this._associateObjWithEvent(this,"_scroll",["left"]));
		}
		if(drawSide) {
			var barSideHeight = configuration.tableHeight-(4*scrollbar.buttonHeight)+configuration.rowHeight;
			scrollbar.barSide=webMI.gfx.addRect({width:scrollbar.barSideWidth,height:barSideHeight,x:xSide,y:ySide+(2*scrollbar.buttonHeight),fill:scrollbar.barFill,stroke:scrollbar.barStroke,strokeWidth:scrollbar.barStrokeWidth}, tableElement);
			scrollbar.buttonUp=webMI.gfx.addRect({width:scrollbar.buttonWidth,height:scrollbar.buttonHeight,x:xSide,y:ySide+scrollbar.buttonHeight,fill:scrollbar.buttonFill,stroke:scrollbar.buttonStroke,strokeWidth:scrollbar.buttonStrokeWidth}, tableElement);
			scrollbar.buttonUpPage=webMI.gfx.addRect({width:scrollbar.buttonWidth,height:scrollbar.buttonHeight,x:xSide,y:ySide,fill:scrollbar.buttonFill,stroke:scrollbar.buttonStroke,strokeWidth:scrollbar.buttonStrokeWidth}, tableElement);
			scrollbar.buttonDown=webMI.gfx.addRect({width:scrollbar.buttonWidth,height:scrollbar.buttonHeight,x:xSide,y:ySide+(2*scrollbar.buttonHeight)+barSideHeight,fill:scrollbar.buttonFill,stroke:scrollbar.buttonStroke,strokeWidth:scrollbar.buttonStrokeWidth}, tableElement);
			scrollbar.buttonDownPage=webMI.gfx.addRect({width:scrollbar.buttonWidth,height:scrollbar.buttonHeight,x:xSide,y:ySide+(3*scrollbar.buttonHeight)+barSideHeight,fill:scrollbar.buttonFill,stroke:scrollbar.buttonStroke,strokeWidth:scrollbar.buttonStrokeWidth}, tableElement);
			scrollbar.barGripHeight = barSideHeight / ((lastItemIndex+1) - (configuration.rowCount-1));
			scrollbar.barSideGrip=webMI.gfx.addRect({width:scrollbar.barSideWidth,height:scrollbar.barGripHeight,x:xSide,y:(ySide+(2*scrollbar.buttonHeight))+((tableElement.scrollRowOffset)*scrollbar.barGripHeight),fill:scrollbar.barGripFill,stroke:scrollbar.buttonStroke,strokeWidth:scrollbar.buttonStrokeWidth}, tableElement);
			//TODO: activate when position detection works (webMI2)... webMI.addEvent(scrollbar.barSide,"mousedown",this._associateObjWithEvent(this,"_scroll",["pos"]));
			webMI.addEvent(scrollbar.buttonUp,"click",this._associateObjWithEvent(this,"_scroll",["up",1]));
			webMI.addEvent(scrollbar.buttonUpPage,"click",this._associateObjWithEvent(this,"_scroll",["up",configuration.rowCount]));
			webMI.addEvent(scrollbar.buttonDown,"click",this._associateObjWithEvent(this,"_scroll",["down",1]));
			webMI.addEvent(scrollbar.buttonDownPage,"click",this._associateObjWithEvent(this,"_scroll",["down",configuration.rowCount]));
			/* TODO: activate _drag Event when _drag function works
			webMI.addEvent(scrollbar.barSideGrip,"mousedown",this._associateObjWithEvent(this,"_drag",[false,true]));
			*/
			//draws arrow for buttonUp
			x1=parseInt(webMI.gfx.getX(scrollbar.buttonUp))+scrollbar.buttonWidth/3;
			y1=parseInt(webMI.gfx.getY(scrollbar.buttonUp))+2*scrollbar.buttonHeight/3;
			x2=x1+scrollbar.buttonWidth/6;
			y2=y1-scrollbar.buttonHeight/3;
			x3=x1+scrollbar.buttonWidth/3;
			y3=y1;
			x4=x1;
			y4=y1;
			scrollbar.buttonUpArrow=webMI.gfx.addPolyline({fill:"#000000",points:[{x:x1,y:y1},{x:x2,y:y2},{x:x3,y:y3},{x:x4,y:y4}],stroke:"#000000",strokeWidth:0},tableElement);
			var factor = 4;
			scrollbar.buttonUpPageArrow=webMI.gfx.addPolyline({fill:"#000000",points:[{x:x1,y:(y1-scrollbar.buttonHeight)-factor},{x:x2,y:(y2-scrollbar.buttonHeight)-factor},{x:x3,y:(y3-scrollbar.buttonHeight)-factor},{x:x4,y:(y4-scrollbar.buttonHeight)-factor},{x:x1,y:(y1-scrollbar.buttonHeight)+factor},{x:x2,y:(y2-scrollbar.buttonHeight)+factor},{x:x3,y:(y3-scrollbar.buttonHeight)+factor},{x:x4,y:(y4-scrollbar.buttonHeight)+factor}],stroke:"#000000",strokeWidth:0},tableElement);
			//draws arrow for buttonDown
			x1=parseInt(webMI.gfx.getX(scrollbar.buttonDown))+scrollbar.buttonWidth/3;
			y1=parseInt(webMI.gfx.getY(scrollbar.buttonDown))+scrollbar.buttonHeight/3;
			x2=x1+scrollbar.buttonWidth/3;
			y2=y1;
			x3=x2-scrollbar.buttonWidth/6;
			y3=y1+scrollbar.buttonHeight/3;
			x4=x1;
			y4=y1;
			scrollbar.buttonDownArrow=webMI.gfx.addPolyline({fill:"#000000",points:[{x:x1,y:y1},{x:x2,y:y2},{x:x3,y:y3},{x:x4,y:y4}],stroke:"#000000",strokeWidth:0},tableElement);
			scrollbar.buttonDownPageArrow=webMI.gfx.addPolyline({fill:"#000000",points:[{x:x1,y:(y1+scrollbar.buttonHeight)-factor},{x:x2,y:(y2+scrollbar.buttonHeight)-factor},{x:x3,y:(y3+scrollbar.buttonHeight)-factor},{x:x4,y:(y4+scrollbar.buttonHeight)-factor},{x:x1,y:(y1+scrollbar.buttonHeight)+factor},{x:x2,y:(y2+scrollbar.buttonHeight)+factor},{x:x3,y:(y3+scrollbar.buttonHeight)+factor},{x:x4,y:(y4+scrollbar.buttonHeight)+factor}],stroke:"#000000",strokeWidth:0},tableElement);
			//events for buttons
			webMI.addEvent(scrollbar.buttonUpArrow,"click", this._associateObjWithEvent(this,"_scroll", ["up",1]));
			webMI.addEvent(scrollbar.buttonUpPageArrow,"click", this._associateObjWithEvent(this,"_scroll", ["up",configuration.rowCount]));
			webMI.addEvent(scrollbar.buttonDownArrow,"click", this._associateObjWithEvent(this,"_scroll",["down",1]));
			webMI.addEvent(scrollbar.buttonDownPageArrow,"click", this._associateObjWithEvent(this,"_scroll",["down",configuration.rowCount]));

//Start - Scroll-function (part 1 / 2) ///////////////////////////////////////////////////	
			//events for mousewheel
			var table = gElement;
			if (table.addEventListener) {
				// IE9, Chrome, Safari, Opera
				table.addEventListener("mousewheel", MouseWheelHandler, true);
				// Firefox
				table.addEventListener("DOMMouseScroll", MouseWheelHandler, true);
			}
			// IE 6/7/8
			else table.attachEvent("onmousewheel", MouseWheelHandler);

//End - Scroll-function (part 1 / 2) ///////////////////////////////////////////////////
		}
	}
	if (this.configuration.drawStatusBar) {
		this._drawStatusBar();
	}
};
// TODO: missing documentation
AtviseTable.prototype._drawSortingArrow = function(){
	var tableElement = this.tableElement;
	var configuration = this.configuration;
	if (tableElement.headerRects.length > 0 && tableElement.headerRects[configuration.sortedByColumn] != undefined) {
		var x1=parseInt(webMI.gfx.getX(tableElement.headerRects[configuration.sortedByColumn]))+parseInt(webMI.gfx.getWidth(tableElement.headerRects[configuration.sortedByColumn]))-10;
		var y1=parseInt(webMI.gfx.getY(tableElement.headerRects[configuration.sortedByColumn]))+parseInt(webMI.gfx.getHeight(tableElement.headerRects[configuration.sortedByColumn]))/2 - 5;
			var x2=x1-10;
		var y2;
		if(configuration.sortingUp)y2=y1-10;
		else y2=y1+10;
		var x3=x2-10;
		var y3=y1;
		var x4=x1;
		var y4=y1;
		if(configuration.sortingUp){y1+=10;y2+=10;y3+=10;y4+=10;}
		this._undrawSortingArrow();

		tableElement.sortingArrow =	webMI.gfx.addPolyline({fill:"#000000",points:[{x:x1,y:y1},{x:x2,y:y2},{x:x3,y:y3},{x:x4,y:y4}],stroke:"#000000",strokeWidth:0},tableElement);

		if (tableElement.headerObjects[configuration.sortedByColumn] != undefined && tableElement.headerObjects[configuration.sortedByColumn].sortable) {
			webMI.addEvent(tableElement.sortingArrow,"click",this._associateObjWithEvent(this,"_sort",[configuration.sortedByColumn]));
		}
	}
};
// TODO: missing documentation
AtviseTable.prototype._drawStatusBar = function() {
	this._undrawStatusBar();
	var tableElement = this.tableElement;
	var statusbar = this.statusbar;
	var configuration = this.configuration;
	var style = this.style;
	var scrollbar = this.scrollbar;
	var x=(tableElement.cellRects[tableElement.scrollColOffset] != undefined && tableElement.cellRects[tableElement.scrollColOffset].length>0)?parseInt(webMI.gfx.getX(tableElement.cellRects[tableElement.scrollColOffset][tableElement.cellRects[tableElement.scrollColOffset].length-1])):0;
	var y=0;
	if(scrollbar.barBottom!=undefined) {
		y=parseFloat(webMI.gfx.getY(scrollbar.barBottom))+scrollbar.barBottomHeight;
	} else if (tableElement.cellRects.length > 0 && tableElement.cellRects[0].length > 0) {
		y=parseFloat(webMI.gfx.getY(tableElement.cellRects[0][tableElement.cellRects[0].length-1])) + configuration.rowHeight;
	} else {
		y=configuration.rowHeight;
	}
	var xWidth = configuration.tableWidth;
	if (scrollbar.barSide!=undefined && configuration.tableWidth + scrollbar.barSideWidth > configuration.displayWidth) {
		xWidth = configuration.displayWidth - scrollbar.barSideWidth;
	}
	// subtract all invisible cells
	if (this.tableElement.headersOutside > 0 && (scrollbar.barSide==undefined || scrollbar.barSide == null)) {
		for (var i=this.tableElement.firstHeaderOutside; i<this.configuration.columnCount; i++) {
			if(this.tableElement.headerRects[i]!=undefined) {
				var width = parseFloat(webMI.gfx.getWidth(this.tableElement.headerRects[i]));
				xWidth -= width;
			}
		}
	}
	var textOffsetY = statusbar.height -((statusbar.height/2)-(statusbar.fontSize/2)) - 2;
	var rowOffset = this.tableElement.scrollRowOffset;
	var lastItemIndex = (this.dataProvider() != null) ? this.dataProvider().lastItemIndex() + 1 : null;
	var rowOffsetEnd = (rowOffset+this.configuration.rowCount);
	if (rowOffsetEnd > lastItemIndex) {
		rowOffsetEnd = lastItemIndex;
	}
	var labelAmountText = (lastItemIndex != null && lastItemIndex > 0) ? "Data: " + (this.tableElement.scrollRowOffset+1) + " - " + rowOffsetEnd + " of " + lastItemIndex : "Data: 0";
	if (statusbar.bar==undefined) {
		statusbar.bar=webMI.gfx.addRect({width:xWidth,height:statusbar.height,x:x,y:y,fill:statusbar.fill,stroke:statusbar.stroke,strokeWidth:statusbar.strokeWidth}, tableElement);
		statusbar.label=webMI.gfx.addText({x:x+style.textOffsetX,y:y+textOffsetY,fontFamily:statusbar.fontFamily,fill:statusbar.fontColor,fontSize:statusbar.fontSize,text:labelAmountText},tableElement);
		var errorText="";
		statusbar.error=webMI.gfx.addText({x:xWidth/2,y:y+textOffsetY,fontFamily:statusbar.fontFamily,fill:statusbar.fontColor,fontSize:statusbar.fontSize,text:errorText},tableElement);
	} else {
		webMI.gfx.setY(statusbar.bar,y);
		webMI.gfx.setY(statusbar.label,y+textOffsetY);
		webMI.gfx.setY(statusbar.error,y+textOffsetY);
		webMI.gfx.setText(statusbar.label, labelAmountText);
		webMI.gfx.setWidth(statusbar.bar,xWidth);
	}
};
// TODO: missing documentation
AtviseTable.prototype._highlightCell = function(e, myArguments) {
	function highlightCell(tableElement, dataProvider, elem, fill) {
		if (elem != undefined && fill != undefined) {
			if (!highlight) {
				if (elem.row != undefined && elem.column != undefined) {
					var dataObj = dataProvider.dataObject((elem.row+1), (elem.column+1));
					if (dataObj != undefined && dataObj.fill != undefined ) {
						fill = dataObj.fill;
					}
				} else {
					if (tableElement.headerObjects[elem.column] != undefined && tableElement.headerObjects[elem.column].fill != undefined) {
						fill = tableElement.headerObjects[elem.column].fill;
					}
				}
			}
			webMI.gfx.setFill(elem,fill);
		}
	}
	function getCellFill(tableElement, dataProvider, elem) {
		if(elem != undefined) {
			var fill = elem.originalColor;
			var dataObj = dataProvider.dataObject((elem.row+1), (elem.column+1));
			if (dataObj != undefined && dataObj.fill != undefined) {
				fill = dataObj.fill;
			}
			return fill;
		}
	}


	var dataProvider = this.dataProvider();
	var elem = (myArguments[0])?myArguments[0]:null;

	var highlight = (myArguments[1])?myArguments[1]:false;
	var fill = (highlight)?this.style.highlight.fill:getCellFill(this.tableElement, dataProvider, elem);


	if ((elem.row != this.tableElement.selectedRow) && (elem.column != this.tableElement.selectedColumn)) {
		highlightCell(this.tableElement, dataProvider, elem,fill);
		if (this.configuration.selectRow && elem.row != undefined) {
			if (elem.row != this.tableElement.selectedRow) {
				for (var i=0; i<this.configuration.columnCount; i++) {
					if (i != this.tableElement.selectedColumn) {
						highlightCell(this.tableElement,this.tableElement.cellRects[i][elem.row], (highlight)?fill:getCellFill(this.tableElement, this.tableElement.cellRects[i][elem.row]));
					}
				}
			}
		}
		if(this.configuration.selectColumn && elem.column != undefined) {
			if (elem.column != this.tableElement.selectedColumn) {
				for (var i=0; i<this.configuration.rowCount; i++) {
					if (i != this.tableElement.selectedRow) {
						highlightCell(this.tableElement,this.tableElement.cellRects[elem.column][i], (highlight)?fill:getCellFill(this.tableElement, this.tableElement.cellRects[elem.column][i]));
					}
				}
			}
		}
	}
};
// TODO: missing documentation
AtviseTable.prototype._init = function(config) {
	var displayWidth = 1280;
	var displayHeight = 1024;
	if (this.hasVML && this.tableElement.getAttribute("atv:table-width") != undefined) {
		displayWidth = parseFloat(this.tableElement.getAttribute("atv:table-width"));
	} else if (this.hasSVG && this.tableElement.getAttributeNS("http://webmi.atvise.com/2007/svgext","table-width") != undefined && this.tableElement.getAttributeNS("http://webmi.atvise.com/2007/svgext","table-width") != "") {
		displayWidth = parseFloat(this.tableElement.getAttributeNS("http://webmi.atvise.com/2007/svgext","table-width"));
	}
	if (this.hasVML && this.tableElement.getAttribute("atv:table-height") != undefined) {
		displayHeight = parseFloat(this.tableElement.getAttribute("atv:table-height"));
	} else if (this.hasSVG && this.tableElement.getAttributeNS("http://webmi.atvise.com/2007/svgext","table-height") != undefined && this.tableElement.getAttributeNS("http://webmi.atvise.com/2007/svgext","table-height") != "") {
		displayHeight = parseFloat(this.tableElement.getAttributeNS("http://webmi.atvise.com/2007/svgext","table-height"));
	}

//	this._setProperties(this.configuration, {displayWidth:parseFloat(displayWidth), displayHeight:parseFloat(displayHeight), rowHeight: 25, rowCount: 0, columnCount: 0, tableHeight: 0, tableWidth: 0, sortable: true, sortingUp: false, sortedByColumn: 0, scrollbarSize: 25, drawStatusBar: true, highlightCells: true, selectRow:false, selectColumn:false, autoResize: false, selectFixed: false});
	this._setProperties(config, {displayWidth:parseFloat(displayWidth), displayHeight:parseFloat(displayHeight), rowHeight: 25, rowCount: 0, columnCount: 0, tableHeight: 0, tableWidth: 0, sortable: true, sortingUp: false, sortedByColumn: 0, scrollbarSize: 25, drawStatusBar: true, highlightCells: true, selectRow:false, selectColumn:false, autoResize: false, selectFixed: false});
	this.configuration = config;
	this._setProperties(this.style, {header: {width: 140, fill: "#868a86", fontFamily: "Arial", fontSize: 16, fontColor: "#000000", stroke: "#000000", strokeWidth:1, sortable: true, resizable: true, cursor: "pointer"}, highlight: {fill: "#fcec3c", selected:"#FFA200"}, stroke: "#000000", strokeWidth: 1, fontFamily: "Arial", fontSize: 14, fontColor: "#000000", cursor: "default", linkColor: "#1F31FF", linkCursor: "pointer", textOffsetX: 5});
	this._setProperties(this.styleEven, this.style);
	this._setProperties(this.styleOdd, this.style);
	this.styleEven.fill = "#EFEFEF";
	this.styleOdd.fill = "#cbcbcb";
	var size = this.configuration.scrollbarSize;
	this._setProperties(this.scrollbar, {buttonHeight: size, buttonWidth: size, barSideWidth: size, barFill: "#eeeeee", barStroke: "#000000", strokeWidth:1, buttonFill: "#999999", buttonStroke: "#000000", buttonStrokeWidth:1, barGripFill: "#C0C0C0", barGripHeight: size, barGripWidth: size});
	this._setProperties(this.statusbar, {height:this.configuration.rowHeight, fill:"#4F4F4F", stroke:"#000000", strokeWidth:1, fontFamily:"Arial", fontSize:12, fontColor:"#000000"});
	this.setDataProvider({data: []});
	// if the tableElement is predefined then load the children
	if (this.tableElement.childNodes.length > 0) {
		this._createPredefinedTable();
	} else {
		this._createTable();
	}
	if (this.configuration.drawStatusBar) {
		this._drawStatusBar();
	}
};
// TODO: missing documentation
AtviseTable.prototype._mouseDownEdit = function(e, myArguments) {
	var tableElement = this.tableElement;
	var elem = (myArguments[0]!=undefined)?myArguments[0]:null;
	var column = (myArguments[1]!=undefined)?myArguments[1]:null;
	var row = (myArguments[2]!=undefined)?myArguments[2]:null;
	var editFunction = (myArguments[3]!=undefined)?myArguments[3]:null;
	if (elem && column != undefined && row != undefined) {
		var inputRect=webMI.gfx.addRect({width:webMI.gfx.getWidth(elem),height:webMI.gfx.getHeight(elem),x:webMI.gfx.getX(elem),y:webMI.gfx.getY(elem),fill:"none",stroke:"#0000FF",strokeWidth:3}, tableElement);
		var isPanel = navigator.userAgent.indexOf("WebKitWinCE") != -1;
		if (isPanel) {
			// TODO: open keyboard correctly if is panel
			//webMI.display.openWindow({display:"SYSTEM.DISPLAYS.touchpanel_demo.elements.keyboard.keyboard",extern:false,height:211,menubar:false,modal:false,movable:true,resizable:false,scrollbars:false,status:false,title:"",toolbar:false,width:528,x:0,y:100,query:webMI.query});
		} else {
			var input = prompt("User input for " + tableElement.cellTextContents[column][row] + ":", "");	//input prompt in Browser
			if(input) {
				if (editFunction != null) {
					var srcText = tableElement.cellTextContents[column][row];
					myArguments[3] = srcText;
					editFunction(e, myArguments, input);
				} else {
					this._setCellContent(e, row, column, true, { text: input });
				}
			}
		}
		tableElement.removeChild(inputRect);
	}
};
// TODO: missing documentation
AtviseTable.prototype._mouseDownEditHeader = function(e, myArguments) {
	var tableElement = this.tableElement;
	var elem = (myArguments[0]!=undefined)?myArguments[0]:null;
	var column = (myArguments[1]!=undefined)?myArguments[1]:null;
	if (elem != null && column > -1) {
		var inputRect=webMI.gfx.addRect({width:webMI.gfx.getWidth(elem),height:webMI.gfx.getHeight(elem),x:webMI.gfx.getX(elem),y:webMI.gfx.getY(elem),fill:"none",stroke:"#0000FF",strokeWidth:1}, tableElement);
		var isPanel = navigator.userAgent.indexOf("WebKitWinCE") != -1;
		if (isPanel) {
			// TODO: open keyboard correctly if is panel
			//webMI.display.openWindow({display:"SYSTEM.DISPLAYS.touchpanel_demo.elements.keyboard.keyboard",extern:false,height:211,menubar:false,modal:false,movable:true,resizable:false,scrollbars:false,status:false,title:"",toolbar:false,width:528,x:0,y:100,query:webMI.query});
		} else {
			var input = prompt("Edit header width: ",webMI.gfx.getWidth(elem));	//input prompt in Browser
			if(input) {
				var newWidth = parseFloat(input);
				tableElement.headerObjects[column].width = newWidth;
				this.setHeader(tableElement.headerObjects[column],(column+1),true);
			}
		}
		tableElement.removeChild(inputRect);
	}
};
// TODO: missing documentation
AtviseTable.prototype._scroll = function(e, myArguments){
	var scrollDirection = myArguments[0];
	var scrollbar = this.scrollbar;
	var scrollOffset = parseFloat(myArguments[1]);
	var tableElement = this.tableElement;
	var configuration = this.configuration;
	var doScroll = true;
	function moveGrid(tableElement, scrollbar, right, configuration) {
		var multiplicator=(right)?-1:1;
		var calc = (right)?0:-1;
		var	preWidth = parseFloat(tableElement.headerObjects[tableElement.scrollColOffset+calc].width);
		tableElement.scrollColOffset=tableElement.scrollColOffset+(-1*multiplicator);
		for (var i=0; i<tableElement.headerRects.length; ++i) {
			if (i==(tableElement.scrollColOffset) && tableElement.sortingArrow != null) {
				var moveOffset = 0;
				for (var offset=0; offset<tableElement.scrollColOffset; ++offset) {
					moveOffset += parseFloat(tableElement.headerObjects[offset].width);
				}
				var visible = (configuration.sortedByColumn > 1) || (-1) * moveOffset >= 0;
				webMI.gfx.setMoveX(tableElement.sortingArrow,(-1)*moveOffset);
				webMI.gfx.setVisible(tableElement.sortingArrow, visible);
			}
			var oldXrect = parseFloat(webMI.gfx.getX(tableElement.headerRects[i]));
			var oldXtext = parseFloat(webMI.gfx.getX(tableElement.headerTexts[i]));
			webMI.gfx.setX(tableElement.headerRects[i],oldXrect+(multiplicator*preWidth));
			webMI.gfx.setX(tableElement.headerTexts[i],oldXtext+(multiplicator*preWidth));
			var width = parseFloat(webMI.gfx.getWidth(tableElement.headerRects[i]));
			var visible = ((oldXrect+(multiplicator*preWidth) + width) < configuration.displayWidth && (oldXrect+(multiplicator*preWidth) + width) > 0);
			webMI.gfx.setVisible(tableElement.headerRects[i],visible);
			webMI.gfx.setVisible(tableElement.headerTexts[i],visible);
			for (var j=0; j<tableElement.cellRects[i].length; ++j) {
				oldXtext = parseFloat(webMI.gfx.getX(tableElement.cellTexts[i][j]));
				webMI.gfx.setX(tableElement.cellRects[i][j],oldXrect+(multiplicator*preWidth));
				webMI.gfx.setX(tableElement.cellTexts[i][j],oldXtext+(multiplicator*preWidth));
				var width = parseFloat(webMI.gfx.getWidth(tableElement.cellRects[i][j]));
				var visible = ((oldXrect+(multiplicator*preWidth) + width) < configuration.displayWidth && (oldXrect+(multiplicator*preWidth) + width) > 0);
				webMI.gfx.setVisible(tableElement.cellRects[i][j],visible);
				webMI.gfx.setVisible(tableElement.cellTexts[i][j],visible);
			}
		}
		var bottomWidth = parseFloat(webMI.gfx.getWidth(scrollbar.barBottom)) - (2*scrollbar.buttonWidth);
		webMI.gfx.setMoveX(scrollbar.barBottomGrip,((bottomWidth-scrollbar.barGripWidth)/tableElement.headersOutside)*tableElement.scrollColOffset);
	}
	switch(scrollDirection){
		case "right" :
			doScroll=false;
			var lastHeaderX = parseFloat(webMI.gfx.getX(tableElement.headerRects[tableElement.headerRects.length-1]));
			var lastHeaderWidth = parseFloat(tableElement.headerObjects[tableElement.headerObjects.length-1].width);
			var lastHeaderPos = lastHeaderX + lastHeaderWidth;
			if ((lastHeaderPos > configuration.displayWidth) && (configuration.tableWidth > configuration.displayWidth)) {
				moveGrid(tableElement,scrollbar,true,configuration);
			}
			break;
		case "left":
			doScroll=false;
			if (tableElement.scrollColOffset > 0) {
				moveGrid(tableElement,scrollbar,false,configuration);
			}
			break;
		case "up":
			if (tableElement.scrollRowOffset > 0) {
				tableElement.scrollRowOffset = tableElement.scrollRowOffset - scrollOffset;
				if(tableElement.scrollRowOffset < 0) {
					tableElement.scrollRowOffset = 0;
				}
				this.dataProvider().previous(scrollOffset);
				webMI.gfx.setMoveY(this.scrollbar.barSideGrip,tableElement.scrollRowOffset*this.scrollbar.barGripHeight);
			} else { doScroll=false; }
			break;
		case "down":
			 var downStep = scrollOffset;
			 var lastItemIndex = this.dataProvider().lastItemIndex() + 1;
			 if ((tableElement.scrollRowOffset + configuration.rowCount) < lastItemIndex) {
				tableElement.scrollRowOffset = tableElement.scrollRowOffset + scrollOffset;
				if(tableElement.scrollRowOffset + configuration.rowCount > lastItemIndex) {
					downStep = lastItemIndex - tableElement.scrollRowOffset;
					tableElement.scrollRowOffset = lastItemIndex - configuration.rowCount;
				}
				this.dataProvider().next(downStep);
				webMI.gfx.setMoveY(this.scrollbar.barSideGrip, tableElement.scrollRowOffset*this.scrollbar.barGripHeight);
			} else { doScroll=false; }
			break;
		case "pos":
			// TODO: determine offset (SVG coordinates needed -> webMI 2.0)
			break;
		default: alert("???_scroll???"); break;
	}
	if (doScroll) {
		this._setDataExtract();
	}
};
// TODO: missing documentation
AtviseTable.prototype._selectCell = function(e, myArguments) {
	function getCellFill(dataProvider, elem) {
		var originalFill = elem.originalColor;
		var dataObj = (dataProvider != null) ? dataProvider.dataObject((elem.row+1), (elem.column+1)) : undefined;
		if (dataObj != undefined && dataObj.fill != undefined ) {
			originalFill = dataObj.fill;
		}
		return originalFill;
	}
	var dataProvider = this.dataProvider();
	var sameRow = false;
	var sameColumn = false;
	var selectedFill = this.style.highlight.selected;
	var elem = myArguments[0];
	if (elem != undefined && elem.row != undefined && elem.column != undefined) {
		if (elem.row != this.tableElement.selectedRow || elem.column != this.tableElement.selectedColumn) {
			webMI.gfx.setFill(elem,selectedFill);
		} else {
			webMI.gfx.setFill(elem,getCellFill(dataProvider, elem));
		}
		if (this.configuration.selectRow) {
			// unhighlight selected cells
			if (this.tableElement.selectedRow > -1 && elem.row != this.tableElement.selectedRow) {
				for (var i=0; i<this.configuration.columnCount; i++) {
					if (i != this.tableElement.selectedColumn) {
						webMI.gfx.setFill(this.tableElement.cellRects[i][this.tableElement.selectedRow],getCellFill(dataProvider, this.tableElement.cellRects[i][this.tableElement.selectedRow]));
					}
				}
			}
			if (elem.row != this.tableElement.selectedRow) {
				// highlight new cells
				for (var i=0; i<this.configuration.columnCount; i++) {
					webMI.gfx.setFill(this.tableElement.cellRects[i][elem.row],selectedFill);
				}
				this.tableElement.selectedRow = elem.row;
			} else {
				sameRow = true;
			}
		}
		if (this.configuration.selectColumn) {
			// unhighlight selected cells
			if (this.tableElement.selectedColumn > -1 && elem.column != this.tableElement.selectedColumn) {
				for (var i=0; i<this.configuration.rowCount; i++) {
					if (i != this.tableElement.selectedRow) {
						webMI.gfx.setFill(this.tableElement.cellRects[this.tableElement.selectedColumn][i],getCellFill(dataProvider, this.tableElement.cellRects[this.tableElement.selectedColumn][i]));
					}
				}
			}
			if (elem.column != this.tableElement.selectedColumn) {
				// highlight new cells
				for (var i=0; i<this.configuration.rowCount; i++) {
					webMI.gfx.setFill(this.tableElement.cellRects[elem.column][i],selectedFill);
				}
				this.tableElement.selectedColumn = elem.column;
			} else {
				sameColumn = true;
			}
		}
		if ((sameRow && sameColumn) && (this.configuration.selectRow && this.configuration.selectColumn)) {
			if (!this.configuration.selectFixed) {
				// unhighlight all selected cells & rows
				for (var i=0; i<this.configuration.rowCount; i++) {
					webMI.gfx.setFill(this.tableElement.cellRects[elem.column][i],getCellFill(dataProvider, this.tableElement.cellRects[elem.column][i]));
				}
				for (var i=0; i<this.configuration.columnCount; i++) {
					webMI.gfx.setFill(this.tableElement.cellRects[i][elem.row],getCellFill(dataProvider, this.tableElement.cellRects[i][elem.row]));
				}
				this.tableElement.selectedRow = -1;
				this.tableElement.selectedColumn = -1;
			}
		} else if (sameRow && this.configuration.selectRow && !this.configuration.selectColumn) {
			if (!this.configuration.selectFixed) {
				for (var i=0; i<this.configuration.columnCount; i++) {
					webMI.gfx.setFill(this.tableElement.cellRects[i][elem.row],getCellFill(dataProvider, this.tableElement.cellRects[i][elem.row]));
				}
				this.tableElement.selectedRow = -1;
			}
		} else if (sameColumn && this.configuration.selectColumn && !this.configuration.selectRow) {
			if (!this.configuration.selectFixed) {
				for (var i=0; i<this.configuration.rowCount; i++) {
					webMI.gfx.setFill(this.tableElement.cellRects[elem.column][i],getCellFill(dataProvider, this.tableElement.cellRects[elem.column][i]));
				}
				this.tableElement.selectedColumn = -1;
			}
		}
	}
};
// TODO: missing documentation
AtviseTable.prototype._setCellContent = function(e, rowNr, colNr, overwrite, dataObj){
	var tableElement = this.tableElement;
	var style = this._cellStyle((rowNr%2==0));
	var newValue = (dataObj != undefined) ? String(dataObj.text) : "";
	var fill = style.fill;
	var fontColor = style.fontColor;
	var fontSize = style.fontSize;
	var fontFamily = style.fontFamily;
	var stroke = style.stroke;
	var strokeWidth = style.strokeWidth;
	var cursor = style.cursor;

	// remove cell if it already has an event attached (workaround, because removeEvent doesnt work)
	if (tableElement.cellRects[colNr][rowNr].hasEvent != undefined) {
		var x = parseFloat(webMI.gfx.getX(tableElement.cellRects[colNr][rowNr]));
		var y = parseFloat(webMI.gfx.getY(tableElement.cellRects[colNr][rowNr]));
		tableElement.removeChild(tableElement.cellRects[colNr][rowNr]);
		tableElement.removeChild(tableElement.cellTexts[colNr][rowNr]);
		tableElement.cellRects[colNr][rowNr] = null;
		tableElement.cellTexts[colNr][rowNr] = null;
		tableElement.cellTextContents[colNr][rowNr] = null;
		var cellStyle = this._cellStyle((rowNr%2==0));
		cellStyle.fill = fill;
		this._createCell(colNr,rowNr,x,y,cellStyle);
	}
	if (tableElement.cellTexts[colNr][rowNr]!=undefined) {
		tableElement.cellTextContents[colNr][rowNr]=newValue;
		var maskedElement = (typeof tableElement.maskingFunctions[colNr] === "undefined") ?
			tableElement.cellTextContents[colNr][rowNr] :
			tableElement.maskingFunctions[colNr]( tableElement.cellTextContents[colNr][rowNr] );

		webMI.gfx.setText(tableElement.cellTexts[colNr][rowNr],maskedElement);
		webMI.gfx.setFill(tableElement.cellTexts[colNr][rowNr],style.fontColor);
		if (dataObj != undefined) {
			// update styling
			if (dataObj.fontSize != undefined) {
				fontSize = dataObj.fontSize;
			}
			webMI.gfx.setFontSize(tableElement.cellTexts[colNr][rowNr], fontSize);
			if (dataObj.fontFamily != undefined) {
				fontFamily = dataObj.fontFamily;
			}
			webMI.gfx.setFontFamily(tableElement.cellTexts[colNr][rowNr], fontFamily);
			if (dataObj.fontColor != undefined) {
				fontColor = dataObj.fontColor;
			}
			webMI.gfx.setFill(tableElement.cellTexts[colNr][rowNr], fontColor);
			if (dataObj.stroke != undefined) {
				stroke = dataObj.stroke;
			}
			webMI.gfx.setStroke(tableElement.cellRects[colNr][rowNr], stroke);
			if (dataObj.strokeWidth != undefined) {
				strokeWidth = dataObj.strokeWidth;
			}
			webMI.gfx.setStrokeWidth(tableElement.cellRects[colNr][rowNr], strokeWidth);
			if (dataObj.cursor != undefined) {
				cursor = dataObj.cursor;
			}
			if (dataObj.fill != undefined) {
				fill = dataObj.fill;
			}
			webMI.gfx.setFill(tableElement.cellRects[colNr][rowNr], fill);
			tableElement.cellRects[colNr][rowNr].setAttribute("cursor", cursor);
			tableElement.cellTexts[colNr][rowNr].setAttribute("cursor", cursor);
			// update events
			var editFunction = null;
			if (dataObj.eventList && dataObj.eventList.length > 0) {
				for (var eventObjEntry in dataObj.eventList) {
					var eventObj = dataObj.eventList[eventObjEntry];
					if (eventObj.name != "edit") {
						webMI.addEvent(tableElement.cellRects[colNr][rowNr], eventObj.name, eventObj.fn);
						webMI.addEvent(tableElement.cellTexts[colNr][rowNr], eventObj.name, eventObj.fn);
					} else {
						editFunction = eventObj.fn;
					}
				}
				tableElement.cellRects[colNr][rowNr].hasEvent=true;
			}
			if(dataObj.editable || editFunction != null) {
				webMI.addEvent(tableElement.cellRects[colNr][rowNr],"click",this._associateObjWithEvent(this,"_mouseDownEdit",[tableElement.cellRects[colNr][rowNr], colNr, rowNr, editFunction]));
				webMI.addEvent(tableElement.cellTexts[colNr][rowNr],"click",this._associateObjWithEvent(this,"_mouseDownEdit",[tableElement.cellRects[colNr][rowNr], colNr, rowNr, editFunction]));
			}
			if ((dataObj.eventList && dataObj.eventList.length > 0) || dataObj.editable) {
				var linkColor = (dataObj.fontColor)?dataObj.fontColor:style.linkColor;
				var linkCursor = (dataObj.cursor)?dataObj.cursor:style.linkCursor;
				webMI.gfx.setFill(tableElement.cellTexts[colNr][rowNr], linkColor);
				tableElement.cellRects[colNr][rowNr].setAttribute("cursor", linkCursor);
				tableElement.cellTexts[colNr][rowNr].setAttribute("cursor", linkCursor);
				tableElement.cellRects[colNr][rowNr].hasEvent=true;
			}
			if (overwrite) {
				dataObj.text = newValue;
				this.dataProvider().setDataObject(rowNr, colNr, dataObj);
			}
		}
	}
};
// TODO: missing documentation
AtviseTable.prototype._setDataExtract = function(dataExtract) {
	var data = (dataExtract == undefined) ? this.dataProvider().data() : dataExtract;
	var configuration = this.configuration;
	var lastItemIndex = (this.dataProvider().lastItemIndex())+1;
	if (this.tableElement.scrollRowOffset >= lastItemIndex) {
		this.tableElement.scrollRowOffset = 0;
	}
	if (data != undefined) {
		var rowCount = configuration.rowCount;
		var columnCount = configuration.columnCount;
		// adjust rows, if table requires autoResize
		if (configuration.autoResize) {
			if (rowCount < lastItemIndex) {
				for (var i=rowCount; i<lastItemIndex; i++) {
					this.addRow(false);
				}
			} else if (lastItemIndex < rowCount && lastItemIndex != -1) {
				this.tableElement.scrollRowOffset = 0;
				var offset = lastItemIndex;
				for (var i=rowCount; i>offset; i--) {
					this.removeRow(i,false,false);
				}
			}

			// adjust columns, if table requires autoResize
			if (data[0] != undefined) {
				if (columnCount < data[0].length) {
					for (var i=(columnCount+1); i<(data[0].length+1); i++) {
						this.addColumn(i);
					}
				} else if (data[0].length < columnCount) {
					this.tableElement.scrollColOffset = 0;
					var offset = data[0].length;
					for (var i=columnCount; i>offset; i--) {
						this.removeColumn(i);
					}
				}
			}
			rowCount = configuration.rowCount;
			columnCount = configuration.columnCount;
		}

		if (lastItemIndex < rowCount && lastItemIndex != -1) {
			for (var i=lastItemIndex; i<rowCount; i++) {
				for (var j=0; j<columnCount; j++) {
					this._setCellContent(null, i, j, false, null);
				}
			}
		}
		var rowOffset = 0;
		var rowOffsetEnd = rowCount;
		if (rowOffsetEnd > lastItemIndex) {
			rowOffsetEnd = lastItemIndex;
		}

		var colOffset = 0;
		var colOffsetEnd = (colOffset+(configuration.columnCount));
		var rowNr = 0, colNr = 0;
		for (var i=rowOffset; i<rowOffsetEnd; i++) {
			for (var j=colOffset; j<colOffsetEnd; j++) {
				var dataObj = data[i] ? data[i][j] : { text: "" };
				this._setCellContent(null, rowNr, colNr, false, dataObj);
				++colNr;
			}
			++rowNr;
			colNr = 0;
		}
	}
	this._drawScrollBars();
};
// TODO: missing documentation
AtviseTable.prototype._setProperties = function(obj, properties) {
	var overwrite = (arguments[2])?arguments[2]:false;
	if (typeof obj == "object") {
		for (var i in properties) {
			if(obj[i] == undefined || overwrite) {
				if (typeof obj[i] == "object") {
					this._setProperties(obj[i], properties[i], overwrite);
				} else {
					obj[i] = properties[i];
				}
			}
		}
	}
	return obj;
};
// TODO: missing documentation
AtviseTable.prototype._sort = function(e, myArguments){
	var col = myArguments[0];
	var dontInvert = myArguments[1];
	var tableElement = this.tableElement;
	var configuration = this.configuration;
	var data = this.dataProvider().data();
	if (configuration.sortable) {
		if(configuration.sortedByColumn!=col) configuration.sortingUp=false;	// if new column was chosen to sort by
		if(!dontInvert) {
			configuration.sortingUp=!configuration.sortingUp;
		}
		configuration.sortedByColumn=col;			//remembers by which column the table was sorted the last time
		this.dataProvider().sort(col, configuration.sortingUp);
		this.tableElement.selectedRow = -1;
		this.tableElement.selectedColumn = -1;
		this._drawSortingArrow();
	}
};
// TODO: missing documentation
AtviseTable.prototype._undrawAll = function(){
	while(this.tableElement.hasChildNodes()){
		this.tableElement.removeChild(this.tableElement.lastChild);
	}
};
// TODO: missing documentation
AtviseTable.prototype._undrawScrollBars = function(){
	var tableElement = this.tableElement;
	function removeElementAndSetNull(parent,child) {
		if(parent != null && child != null) {
			try {
				parent.removeChild(child);
			} catch(e) {}
		}
		return null;
	}
	var scrollbar = this.scrollbar;
	if(scrollbar != undefined) {
		scrollbar.barDecoRect = removeElementAndSetNull(tableElement,scrollbar.barDecoRect);
		scrollbar.barSide = removeElementAndSetNull(tableElement,scrollbar.barSide);
		scrollbar.barSideGrip =  removeElementAndSetNull(tableElement,scrollbar.barSideGrip);
		scrollbar.barBottom = removeElementAndSetNull(tableElement,scrollbar.barBottom);
		scrollbar.barBottomGrip = removeElementAndSetNull(tableElement,scrollbar.barBottomGrip);
		scrollbar.buttonLeft = removeElementAndSetNull(tableElement,scrollbar.buttonLeft);
		scrollbar.buttonRight = removeElementAndSetNull(tableElement,scrollbar.buttonRight);
		scrollbar.buttonUp = removeElementAndSetNull(tableElement,scrollbar.buttonUp);
		scrollbar.buttonUpPage = removeElementAndSetNull(tableElement,scrollbar.buttonUpPage);
		scrollbar.buttonDown = removeElementAndSetNull(tableElement,scrollbar.buttonDown);
		scrollbar.buttonDownPage = removeElementAndSetNull(tableElement,scrollbar.buttonDownPage);
		scrollbar.buttonRightArrow = removeElementAndSetNull(tableElement,scrollbar.buttonRightArrow);
		scrollbar.buttonLeftArrow = removeElementAndSetNull(tableElement,scrollbar.buttonLeftArrow);
		scrollbar.buttonUpArrow = removeElementAndSetNull(tableElement,scrollbar.buttonUpArrow);
		scrollbar.buttonUpPageArrow = removeElementAndSetNull(tableElement,scrollbar.buttonUpPageArrow);
		scrollbar.buttonDownArrow = removeElementAndSetNull(tableElement,scrollbar.buttonDownArrow);
		scrollbar.buttonDownPageArrow = removeElementAndSetNull(tableElement,scrollbar.buttonDownPageArrow);
	}
	if (this.configuration.drawStatusBar) {
		this._drawStatusBar();
	}
};
// TODO: missing documentation
AtviseTable.prototype._undrawSortingArrow = function(){
	if(this.tableElement.sortingArrow!=null) {
		this.tableElement.removeChild(this.tableElement.sortingArrow);
		this.tableElement.sortingArrow=null;
	}
};
// TODO: missing documentation
AtviseTable.prototype._undrawStatusBar = function() {
	var tableElement = this.tableElement;
	function removeElementAndSetNull(parent,child) {
		if(parent != null && child != null) {
			try {
				parent.removeChild(child);
			} catch(e) {}
		}
		return null;
	}
	var statusbar = this.statusbar;
	if(statusbar != undefined) {
		statusbar.bar = removeElementAndSetNull(tableElement,statusbar.bar);
		statusbar.label = removeElementAndSetNull(tableElement,statusbar.label);
		statusbar.error = removeElementAndSetNull(tableElement,statusbar.error);
	}
};
// TODO: missing documentation
AtviseTable.prototype._updateHeader = function(column) {
	var tableElement = this.tableElement;
	var configuration = this.configuration;
	var style = this.style;

	if (tableElement.headerObjects[column]) {
		// rearrange all following headers and cells if the width has changed
		var currentWidth = parseFloat(webMI.gfx.getWidth(tableElement.headerRects[column]));
		if (currentWidth != tableElement.headerObjects[column].width) {
			webMI.gfx.setWidth(tableElement.headerRects[column], tableElement.headerObjects[column].width);
			for (var i=0; i<configuration.rowCount; i++) {
				webMI.gfx.setWidth(tableElement.cellRects[column][i], tableElement.headerObjects[column].width);
			}
			var currentX = parseFloat(webMI.gfx.getX(tableElement.headerRects[column]));
			if (this.hasVML) {
				webMI.gfx.setX(tableElement.headerTexts[column], currentX + style.textOffsetX);
			} else {
				webMI.gfx.setX(tableElement.headerTexts[column], currentX + (tableElement.headerObjects[column].width / 2));
			}

			var diff = currentWidth - tableElement.headerObjects[column].width;
			// headers
			for (var i=(column+1); i<tableElement.headerRects.length; i++) {
				var startX = parseFloat(webMI.gfx.getX(tableElement.headerRects[i]));
				var newX = startX + (-1) * diff;
				webMI.gfx.setX(tableElement.headerRects[i], newX);
				var headerWidth = parseFloat(webMI.gfx.getWidth(tableElement.headerRects[i]));
				if (this.hasVML) {
					webMI.gfx.setX(tableElement.headerTexts[i], newX + style.textOffsetX);
				} else {
					webMI.gfx.setX(tableElement.headerTexts[i], newX + (headerWidth/2));
				}
				// cells
				for (var j=0; j<configuration.rowCount; j++) {
					webMI.gfx.setX(tableElement.cellRects[i][j], newX);
					webMI.gfx.setX(tableElement.cellTexts[i][j], newX + style.textOffsetX);
				}
			}
		}
		// remove cell if it already has an event attached (workaround, because removeEvent doesn't work)
		if (tableElement.headerRects[column] && tableElement.headerRects[column].hasEvent != undefined) {
			this.removeColumn((column+1), false, false, false);
			this.addColumn((column+1), false);
		}
		webMI.gfx.setText(tableElement.headerTexts[column],tableElement.headerObjects[column].name);
		if (tableElement.headerObjects[column].sortable == true) {
			webMI.addEvent(tableElement.headerRects[column],"click",this._associateObjWithEvent(this,"_sort",[column]));
			webMI.addEvent(tableElement.headerTexts[column],"click",this._associateObjWithEvent(this,"_sort",[column]));
		}

		if (tableElement.headerObjects[column].resizable == true) {
			webMI.addEvent(tableElement.headerRects[column],"dblclick",this._associateObjWithEvent(this,"_mouseDownEditHeader",[tableElement.headerRects[column],column]));
			webMI.addEvent(tableElement.headerTexts[column],"dblclick",this._associateObjWithEvent(this,"_mouseDownEditHeader",[tableElement.headerRects[column],column]));
		}
		if (configuration.highlightCells == true) {
			webMI.addEvent(tableElement.headerRects[column],"mouseover",this._associateObjWithEvent(this,"_highlightCell",[tableElement.headerRects[column],true]));
			webMI.addEvent(tableElement.headerTexts[column],"mouseover",this._associateObjWithEvent(this,"_highlightCell",[tableElement.headerRects[column],true]));
			webMI.addEvent(tableElement.headerRects[column],"mouseout",this._associateObjWithEvent(this,"_highlightCell",[tableElement.headerRects[column],false]));
			webMI.addEvent(tableElement.headerTexts[column],"mouseout",this._associateObjWithEvent(this,"_highlightCell",[tableElement.headerRects[column],false]));
		}
		if (tableElement.headerObjects[column].eventList && tableElement.headerObjects[column].eventList.length > 0) {
			for (var eventObjEntry in tableElement.headerObjects[column].eventList) {
				webMI.addEvent(tableElement.headerRects[column], tableElement.headerObjects[column].eventList[eventObjEntry].name, tableElement.headerObjects[column].eventList[eventObjEntry].fn);
				webMI.addEvent(tableElement.headerTexts[column], tableElement.headerObjects[column].eventList[eventObjEntry].name, tableElement.headerObjects[column].eventList[eventObjEntry].fn);
			}
		}
		if ((tableElement.headerObjects[column].eventList && tableElement.headerObjects[column].eventList.length > 0) || tableElement.headerObjects[column].sortable || tableElement.headerObjects[column].resizable) {
			tableElement.headerRects[column].setAttribute("cursor", tableElement.headerObjects[column].cursor);
			tableElement.headerTexts[column].setAttribute("cursor", tableElement.headerObjects[column].cursor);
			tableElement.headerRects[column].hasEvent = true;
		}
		var fill = style.fill;
		var stroke = style.stroke;
		if (tableElement.headerObjects[column].fill != undefined) {
			fill = tableElement.headerObjects[column].fill;
		}
		webMI.gfx.setFill(tableElement.headerRects[column], fill);
		if (tableElement.headerObjects[column].stroke != undefined) {
			stroke = tableElement.headerObjects[column].stroke;
		}
		webMI.gfx.setStroke(tableElement.headerRects[column], stroke);
	}
};
/*	********** atvise table widget END ********** */
/**
 * The AtviseDataProvider Class.
 * @class
 * @param {Object} source Object containing the source data.
 * @param {Object} configuration Object for configuration of the data provider.
*/
function AtviseDataProvider(source, configuration) {
	if (typeof source == "object") {
		this.source = source;
		this.dataArray = [];
		this.dataExtract = [];
		this.dataFiltered = [];
		this.dataFn = null;
		this.params = null;
		this.types = {
			DATA_PROVIDER_TYPE_ARRAY: "array",
			DATA_PROVIDER_TYPE_XML: "xml",
			DATA_PROVIDER_TYPE_SERVERSIDE: "serverside"
		};
		this.type = this.types.DATA_PROVIDER_TYPE_ARRAY;
		this.listeners = [];
		this.configuration = {maxResults: 100};
		this.offsetStart = 0;
		this.offsetEnd = 0;
		this.filterArray = null;
		this.filteredArrayLength = -1;
		this.sortedByColumn = 0;
		this.sortingUp = false;
		this.init_(configuration);
	}
}
/**
 * Adds an event to a data object at the specified position.
 * @param {Number} rowNr Row index of the data object.
 * @param {Number} colNr Column index of the data object.
 * @param {Object} eventObj Object with event information.
*/
AtviseDataProvider.prototype.addCellEvent = function(rowNr, colNr, eventObj) {
	// decrement user input to array index
	rowNr--;
	colNr--;
	this.addCellEvent_(rowNr, colNr, eventObj, true);
};
/**
 * Adds an event to all data objects of a column.
 * @param {Number} colNr Column index.
 * @param {Object} eventObj Event object.
 * @param {String} eventObj.name Name of the event.
 * @param {Function} eventObj.fn Function that will be called.
*/
AtviseDataProvider.prototype.addColumnEvent = function(colNr, eventObj) {
	// decrement user input to array index
	colNr--;
	if (this.dataArray != undefined && this.dataArray.length > 0) {
		for (var i=0; i<this.dataArray.length; i++) {
			this.addCellEvent_(i,colNr,eventObj,false);
		}
	}
	this.fireDataChanged_();
};
// TODO: missing documentation
AtviseDataProvider.prototype.addItem = function(dataItem, position, overwrite, update) {
	var position = (arguments[1] != undefined) ? arguments[1] : this.dataArray.length;
	var overwrite = (arguments[2] != undefined) ? arguments[2] : false;
	var update = (arguments[3] != undefined) ? arguments[3] : true;
	this.dataArray = this.arrayInsertElement_(this.dataArray, position, dataItem, overwrite);
	this.sort(this.sortedByColumn, this.sortingUp);
	if (update) {
		this.extract_(this.offsetStart, this.offsetEnd);
	}
};
/**
 * Adds an event to all data objects of a row.
 * @param {Number} rowNr Row index.
 * @param {Object} eventObj Event object.
 * @param {String} eventObj.name Name of the event.
 * @param {Function} eventObj.fn Function that will be called.
*/
AtviseDataProvider.prototype.addRowEvent = function(rowNr, eventObj) {
	// decrement user input to array index
	rowNr--;
	if (this.dataArray != undefined && this.dataArray[rowNr] != undefined) {
		for (var i=0; i<this.dataArray[rowNr].length; i++) {
			this.addCellEvent_(rowNr,i,eventObj,false);
		}
	}
	this.fireDataChanged_();
};
/**
 * Returns the current data array of the data provider.
 * @type {Array} dataArray Current data array of the data provider.
*/
AtviseDataProvider.prototype.data = function() {
//	changed with [AT-D-1348] Spaltensortierung geht bei Scrolling verloren on 2011_04_22
//	return this.dataArray;
	return this.sort(this.sortedByColumn, this.sortingUp);
};
/**
 * Returns a data column of the current data array.
 * @param {Number} colNr Column index.
 * @param {Number} [rowOffsetStart] Row offset start.
 * @param {Number} [rowOffsetEnd] Row offset end.
 * @type {Array} dataColumn
*/
AtviseDataProvider.prototype.dataColumn = function(colNr, rowOffsetStart, rowOffsetEnd) {
	// decrement user input to array index
	colNr--;
	rowOffsetStart = (rowOffsetStart==undefined) ? 0 : rowOffsetStart-1;
	rowOffsetEnd = (rowOffsetEnd==undefined) ? this.dataArray.length : rowOffsetEnd-1;
	var dataExtract = [];
	if (this.dataArray != undefined) {
		for (var i=rowOffsetStart; i<rowOffsetEnd; i++) {
			if (this.dataArray[i] != undefined && this.dataArray[i][colNr] != undefined) {
				dataExtract.push(this.dataArray[i][colNr]);
			}
		}
	}
	return dataExtract;
};
/**
 * Returns a data object of the current data array.
 * @param {Number} rowNr Row index.
 * @param {Number} colNr Column index.
 * @type {Object} dataObject
*/
AtviseDataProvider.prototype.dataObject = function(rowNr, colNr) {
	var dataObject = null;
	// decrement user input to array index
	rowNr--;
	colNr--;
	var dataRow = rowNr + this.offsetStart;
	if (this.dataArray != undefined && this.dataArray[dataRow] != undefined && this.dataArray[dataRow][colNr] != undefined) {
		dataObject = this.dataArray[dataRow][colNr];
	}
	return dataObject;
};
/**
 * Returns a data row of the current data array.
 * @param {Number} rowNr Row index.
 * @param {Number} [colOffsetStart] Column offset start.
 * @param {Number} [colOffsetEnd] Column offset end.
 * @type {Array} dataRow
*/
AtviseDataProvider.prototype.dataRow = function(rowNr, colOffsetStart, colOffsetEnd) {
	// decrement user input to array index
	rowNr--;
	colOffsetStart = (colOffsetStart == undefined) ? 0 : colOffsetStart-1;
	var dataCols = (this.dataArray[0] != undefined) ? this.dataArray[0].length : 0;
	colOffsetEnd = (colOffsetEnd == undefined) ? dataCols : colOffsetEnd-1;
	var dataExtract = [];
	if (this.dataArray != undefined) {
		if (this.dataArray[rowNr] != undefined) {
			for (var i=colOffsetStart; i<colOffsetEnd; i++) {
				if (this.dataArray[rowNr][i] != undefined) {
					dataExtract.push(this.dataArray[rowNr][i]);
				}
			}
		}
	}
	return dataExtract;
};
// TODO: missing documentation
AtviseDataProvider.prototype.extract = function(offsetStart, offsetEnd) {
	this.dataExtract = [];
	// decrease input to array indices...
	offsetStart--;
	offsetEnd--;
	if (offsetStart > -1 && offsetStart < this.dataArray.length) {
		this.dataExtract = this.dataArray.slice(offsetStart, offsetEnd);
	}
	this.fireDataChanged_();
};
// TODO: missing documentation
AtviseDataProvider.prototype.filter = function(filterArray) {
	this.filterArray = filterArray;
	if (filterArray == null || this.filterArray.length < 1) {
		this.extract_(this.offsetStart, this.offsetEnd);
	} else {
		this.fireDataChanged_();
	}
};
// TODO: missing documentation
AtviseDataProvider.prototype.hasMore = function(nextOffsetStart, nextOffsetEnd) {
	var hasMore = false;
	if (this.type == this.types.DATA_PROVIDER_TYPE_ARRAY) {
		hasMore = ((nextOffsetStart + this.configuration.maxResults) <= this.dataArray.length);
	} else if (this.type == this.types.DATA_PROVIDER_TYPE_XML) {
		//handle xml
	} else if (this.type == this.types.DATA_PROVIDER_TYPE_SERVERSIDE) {
		var tempData = this.callDataFn_(nextOffsetStart+this.configuration.maxResults, nextOffsetEnd+this.configuration.maxResults);
		hasMore = (typeof tempData == "object" && tempData.constructor.toString().indexOf("Array") != -1);
	}
	return hasMore;
};
// TODO: missing documentation
AtviseDataProvider.prototype.lastItemIndex = function() {
	var lastItemIndex = -1;
	if (this.type == this.types.DATA_PROVIDER_TYPE_ARRAY) {
		if (this.filterArray != null) {
			var delta = (this.dataArray.length-1) - (this.filteredArrayLength-1);
			lastItemIndex = (this.dataArray.length-1) - delta;
		} else {
			lastItemIndex = (this.dataArray.length-1); // - delta;
		}
	} else if (this.type == this.types.DATA_PROVIDER_TYPE_SERVERSIDE) {
		var retValue = webMI.data.call(this.source.lastItemFn, "");
		// TODO: hier fortsetzen...
		lastItemIndex = 200; // retValue.result;
	}
	return lastItemIndex;
};
// TODO: missing documentation
AtviseDataProvider.prototype.next = function(step) {
	this.increaseOffset_(step);
	this.data_();
	this.fireDataChanged_(step);
};
// TODO: missing documentation
AtviseDataProvider.prototype.preloadNext = function(step) {
	this.increaseOffset_(step);
	this.data_();
	this.decreaseOffset_(step);
};
// TODO: missing documentation
AtviseDataProvider.prototype.previous = function(step) {
	this.decreaseOffset_(step);
	this.data_();
	this.fireDataChanged_(step);
};
// TODO: missing documentation
AtviseDataProvider.prototype.removeColumn = function(colNr) {
	colNr--;
	var i = dataArray.length;
	while(i--) {
		if (dataArray[i] != undefined && dataArray[i][colNr] != undefined) {
			dataArray[i].splice(colNr,1);
		}
	}
	this.fireDataChanged_();
};
// TODO: missing documentation
AtviseDataProvider.prototype.removeItem = function(dataItem, identifier, update) {
	if (this.dataArray.length > 0) {
		var rowNr = -1;
		var i = this.dataArray.length-1;
		while (i > -1) {
			if (this.dataArray[i] != undefined) {
				if (this.dataArray[i][identifier] != undefined && this.dataArray[i][identifier] == dataItem[identifier]) {
					rowNr = i;
					break;
				}
			}
			i--;
		}
		if (rowNr > -1) {
			this.dataArray = this.arrayRemoveElement_(this.dataArray, rowNr);
		}
	}
	if (update) {
		this.extract_(this.offsetStart, this.offsetEnd);
	}
};
// TODO: missing documentation
AtviseDataProvider.prototype.removeRow = function(rowNr, update) {
	rowNr--;
	if (this.dataArray[rowNr] != undefined) {
		this.dataArray.splice(rowNr,1);
	}
	if (update) {
		this.fireDataChanged_();
	}
};
/**
 * Sets the style of a data object of a cell.
 * @param {Number} rowNr Row index.
 * @param {Number} colNr Column index.
 * @param {Object} style Style object.
*/
AtviseDataProvider.prototype.setCellStyle = function(rowNr, colNr, style) {
	// decrement user input to array index
	rowNr--;
	colNr--;
	this.setCellStyle_(rowNr, colNr, style, true);
};
/**
 * Sets the configuration object of the data provider.
 * @param {Object} configuration Configuration object
 *
*/
AtviseDataProvider.prototype.setConfiguration = function(configuration) {
	this.setProperties_(this.configuration, configuration);
	this.sortingUp = this.configuration.sortingUp;
	this.sortedByColumn = this.configuration.sortedByColumn;
};
/**
 * Sets the style of all data objects of a column.
 * @param {Number} colNr Column index.
 * @param {Object} style Style object.
*/
AtviseDataProvider.prototype.setColumnStyle = function(colNr, style) {
	// decrement user input to array index
	colNr--;
	if (this.dataArray.length > 0) {
		for (var i=0; i<this.dataArray.length; i++) {
			this.setCellStyle_(i,colNr,style,false);
		}
	}
	this.fireDataChanged_();
};
/**
 * Sets an two-dimensional data array.
 * @param {Array} dataArray Two-dimensional dataArray.
 * @param {Boolean} [appendData] Indicates if the data shall be appended or replaced.
*/
AtviseDataProvider.prototype.setData = function(dataArray, append){
	var append = (arguments[1] != undefined && typeof arguments[1] == "boolean") ? arguments[1] : false;
	if (append && this.dataArray.length > 0) {
		for (var i=0; i<dataArray.length; ++i) {
			this.dataArray.push(dataArray[i]);
		}
		this.sort(this.sortedByColumn, this.sortingUp);
		this.fireDataChanged_();
	} else {
		this.filterArray = null;
		if ((this.dataArray.length != dataArray.length) || (((this.dataArray.length == dataArray.length) && this.filteredArrayLength > 0) && dataArray.length != this.filteredArrayLength)) {
			this.offsetStart = 0;
			this.offsetEnd = this.configuration.maxResults;
		}
		this.dataArray = dataArray;
		this.sort(this.sortedByColumn, this.sortingUp);
		if (this.offsetEnd > (this.lastItemIndex()+2)) {
			this.offsetStart = ((this.lastItemIndex()+2) - this.configuration.maxResults) > -1 ? ((this.lastItemIndex()+2) - this.configuration.maxResults) : 0;
			this.offsetEnd = (this.lastItemIndex()+2);
		} else if (this.offsetEnd < this.configuration.maxResults && (this.lastItemIndex()+2) >= this.configuration.maxResults) {
			this.offsetEnd = this.configuration.maxResults;
		} else if (this.offsetEnd < this.dataArray.length && this.dataArray.length <= this.configuration.maxResults) {
			this.offsetEnd = this.configuration.maxResults;
		}
		this.extract_(this.offsetStart, this.offsetEnd);
	}
};
/**
 * Sets a data column to the data array.
 * @param {Array} dataCol Array of data objects.
 * @param {Number} position Position (default: at the end of the array).
 * @param {Boolean} overwrite Inidicates if the data shall be overriden or not.
*/
AtviseDataProvider.prototype.setDataColumn = function(dataCol) {
	var data = this.dataArray;
	var position = data.length;
	var overwrite = false;
	if (data && data[0] && data[0].length > 0) {
		if(arguments.length>1) {
			if (typeof arguments[1] == "number") {
				position = arguments[1];
			} else {
				return;
			}
			if (typeof arguments[2] == "boolean") {
				overwrite = arguments[2];
			} else {
				return;
			}
		}
		for (var i=0; i<dataCol.length; i++) {
			data = this.arrayInsertElement_(data[position], i, dataCol[i], overwrite);
		}
		this.fireDataChanged_();
	}
};
/**
 * Sets a data object to the table data array.
 * @param {Number} rowNr Row index.
 * @param {Number} colNr Column index.
 * @param {Object} dataObject Data object.
*/
AtviseDataProvider.prototype.setDataObject = function(rowNr, colNr, dataObject) {
	// decrement user input to array index
	rowNr--;
	colNr--;
	var dataRow = this.offsetStart + rowNr;
	if (this.dataArray[dataRow] != undefined && this.dataArray[dataRow][colNr] != undefined) {
		this.dataArray[dataRow][colNr] = dataObject;
		this.fireDataChanged_();
	}
};
/**
 * Sets a data row to the data array.
 * @param {Array} dataRow Array of data objects.
 * @param {Number} position Position (default: at the end of the array).
 * @param {Boolean} overwrite Inidicates if the data shall be overriden or not.
*/
AtviseDataProvider.prototype.setDataRow = function(dataRow) {
	var data = this.dataArray;
	var position = data.length;
	var overwrite = false;
	if(arguments.length>1) {
		if (typeof arguments[1] == "number") {
			position = arguments[1];
		} else {
			return;
		}
		if (typeof arguments[2] == "boolean") {
			overwrite = arguments[2];
		} else {
			return;
		}
	}
	data = this.arrayInsertElement_(data, position, dataRow, overwrite);
	this.fireDataChanged_();
};
/**
 * Sets the style of all data objects of a row.
 * @param {Number} rowNr Row index.
 * @param {Object} style Style object.
*/
AtviseDataProvider.prototype.setRowStyle = function(rowNr, style) {
	// decrement user input to array index
	rowNr--;
	if (this.dataArray[rowNr] != undefined) {
		for (var i=0; i<this.dataArray[rowNr].length; i++) {
			this.setCellStyle_(rowNr,i,style,false);
		}
	}
	this.fireDataChanged_();
};
// TODO: missing documentation
AtviseDataProvider.prototype.sort = function(colNr, sortingUp, sortFn){
	if (this.dataArray.length > 0 && this.dataArray[0][colNr] != undefined) {
		function by(i) {
			return function(a,b) {
				a = a[i];
				b = b[i];
				var multiplicator = (!sortingUp) ? -1 : 1;
				// wenn gleich, dann andere spalte vergleichen?!
				var pos = -1;
				if (a.text == b.text) {
					pos = (a.sortId < b.sortId ? (-1)*multiplicator : 1*multiplicator);
				} else {
					pos = (a.text < b.text ? (-1)*multiplicator : 1*multiplicator);
				}
				return pos;
			};
		};
		var sortByFn = (sortFn != undefined) ? sortFn : by(colNr);
		this.dataArray.sort(sortByFn);
		this.sortedByColumn = colNr;
		this.sortingUp = sortingUp;
		this.extract_(this.offsetStart, this.offsetEnd);
	}
};
// TODO: missing documentation
AtviseDataProvider.prototype.subscribe = function(listener) {
	this.listeners.push(listener);
	listener(this.dataExtract);
};
// TODO: missing documentation
AtviseDataProvider.prototype.unsubscribe = function(listener) {
	var i=this.listeners.length-1;
	while (i > 0) {
		if (this.listeners[i] == listener) {
			this.listeners.splice(i,1);
			break;
		}
		i--;
	}
};
// TODO: missing documentation
AtviseDataProvider.prototype.updateItem = function(dataItem, identifier, update) {
	if (this.dataArray.length > 0) {
		var rowNr = -1;
		var i = this.dataArray.length-1;
		while (i > -1) {
			if (this.dataArray[i] != undefined) {
				if (this.dataArray[i][identifier] != undefined && this.dataArray[i][identifier] == dataItem[identifier]) {
					rowNr = i;
					break;
				}
			}
			i--;
		}
		if (rowNr > -1) {
			this.dataArray = this.arrayInsertElement_(this.dataArray, rowNr, dataItem, true);
		} else {
			this.dataArray.push(dataItem);
		}
		this.sort(this.sortedByColumn, this.sortingUp);
	} else {
		this.dataArray.push(dataItem);
	}
	if (update) {
		this.extract_(this.offsetStart, this.offsetEnd);
	}
};
// *************************
// PRIVATE PUBLIC BORDER
// *************************
/**
 * @private
*/
AtviseDataProvider.prototype.addCellEvent_ = function(rowNr, colNr, eventObj, update) {
	if (this.dataArray != undefined && this.dataArray[rowNr] != undefined && this.dataArray[rowNr][colNr] != undefined) {
		if (this.dataArray[rowNr][colNr].eventList == undefined) {
			this.dataArray[rowNr][colNr].eventList = [];
		}
		this.dataArray[rowNr][colNr].eventList.push(eventObj);
	}
	if (update) {
		this.fireDataChanged_();
	}
};
/**
 * @private
*/
AtviseDataProvider.prototype.arrayInsertElement_ = function(arrayInstance, position, newElement, overwrite) {
	if (arrayInstance.length > 0) {
		if (overwrite) {
			arrayInstance[position] = newElement;
		} else {
			var a = arrayInstance.slice();
			var b = a.splice(position,a.length);
			a[position] = newElement;
			arrayInstance = a.concat(b);
		}
	} else {
		arrayInstance.push(newElement);
	}
	return arrayInstance;
};
/**
 * @private
*/
AtviseDataProvider.prototype.arrayRemoveElement_ = function(arrayInstance, position) {
	if (arrayInstance.length > 0) {
		if (arrayInstance[position] != undefined) {
			arrayInstance.splice(position, 1);
		}
	}
	return arrayInstance;
};
/**
 * @private
*/
AtviseDataProvider.prototype.callDataFn_ = function(offsetStart, offsetEnd) {
	var start = (offsetStart != undefined) ? offsetStart : this.offsetStart;
	var end = (offsetEnd != undefined) ? offsetEnd : this.offsetEnd;
	var serverSideData = webMI.data.call(this.dataFn, "offsetStart="+start+"&offsetEnd="+end+this.parameterList_());
	return (serverSideData != undefined) ? serverSideData : [];
};
/**
 * @private
*/
AtviseDataProvider.prototype.data_ = function() {
	this.dataExtract = [];
	if (this.type == this.types.DATA_PROVIDER_TYPE_ARRAY) {
		if (this.offsetStart < this.dataArray.length) {
			if (this.dataArray != undefined) {
				this.sort(this.sortedByColumn, this.sortingUp);
				this.dataExtract = this.dataArray.slice(this.offsetStart, this.offsetEnd);
			}
		}
	} else if (this.type == this.types.DATA_PROVIDER_TYPE_XML) {

	} else if (this.type == this.types.DATA_PROVIDER_TYPE_SERVERSIDE) {
		if (this.offsetStart < this.dataArray.length) {
			if (this.dataArray != undefined) {
				this.sort(this.sortedByColumn, this.sortingUp);
				this.dataExtract = this.dataArray.slice(this.offsetStart, this.offsetEnd);
			}
		} else {
			this.dataExtract = this.callDataFn_();
			if (this.dataExtract != null && this.dataExtract != undefined) {
				for (var i in this.dataExtract) {
					this.dataArray.push(this.dataExtract[i]);
				}
			}
		}
	}
};
/**
 * @private
*/
AtviseDataProvider.prototype.decreaseOffset_ = function(step) {
	var step = step == undefined ? this.configuration.maxResults : step;
	if (this.offsetStart - step > -1) {
		this.offsetStart -= step;
		this.offsetEnd -= step;
	} else {
		this.offsetStart = 0;
		this.offsetEnd = this.configuration.maxResults;
	}
};
/**
 * @private
*/
AtviseDataProvider.prototype.extract_ = function(offsetStart, offsetEnd) {
	this.extract((offsetStart+1),(offsetEnd+1));
};
/**
 * @private
*/
AtviseDataProvider.prototype.filter_ = function() {
	/*
	 * the characters "\", "?" and "*" must be escaped if it is being explicitly searched by them
	 * wildcard characters are "?" for a single character and "*" for 0 or more characters
	*/
	function applyWildcards(value) {
		var value = value.replace(/[\-\[\]\/\{\}\(\)\+\.\^\$\|]/g, "\\$&")
			.replace(/([^\\])\*/g, "$1.*")
			.replace(/([^\\])\?/g, "$1.");

		if(value.charAt(0) == "*")
			value = ".*" + value.substring(1);

		if(value.charAt(0) == "?")
			value = "." + value.substring(1);

		return value;
	}

	if (this.filterArray != null && this.filterArray.length > 0) {
		var tempExtract = [];
		if (this.dataArray.length > 0) {
			var i = this.dataArray.length-1;
			while (i > -1) {
				var match = 0;
				for (var f in this.filterArray) {
					var filter = this.filterArray[f];
					if (filter.value == undefined || filter.value == "") {
						match++;
					} else {
						var j = this.dataArray[i].length-1;
						while (j > -1) {
							if (this.dataArray[i] != undefined && this.dataArray[i][j] != undefined) {
								if (this.dataArray[i][j].name != undefined && this.dataArray[i][j].text != undefined) {
									if (this.dataArray[i][j].name == filter.name) {
										try {
											switch(filter.type) {
												case "matches":
													var cellContent = this.dataArray[i][j].text.toString();
													var filter = applyWildcards(filter.value.toString());
													if(cellContent.match("^"+filter+"$") != null) {
														match++;
													}
													break;
												case "contains":
													var cellContent = this.dataArray[i][j].text.toString().toLowerCase();
													var filter = applyWildcards(filter.value.toString().toLowerCase());
													if (cellContent.search(filter) > -1) {
														match++;
													}
													break;
												case "valuecontains":
													var cellContent = ("value" in (arr_elem = this.dataArray[i][j])) ? arr_elem.value.toString().toLowerCase() : arr_elem.text.toString().toLowerCase();
													var filter = applyWildcards(filter.value.toString().toLowerCase());
													if (cellContent.search(filter) > -1) {
														match++;
													}
													break;
												case "greaterEqual":
													var cellContent = parseFloat(this.dataArray[i][j].text);
													var filter = parseFloat(filter.value);
													if (cellContent >= filter) {
														match++;
													}
													break;
												case "greaterThan":
													var cellContent = parseFloat(this.dataArray[i][j].text);
													var filter = parseFloat(filter.value);
													if (cellContent > filter) {
														match++;
													}
													break;
												case "lowerEqual":
													var cellContent = parseFloat(this.dataArray[i][j].text);
													var filter = parseFloat(filter.value);
													if (cellContent <= filter) {
														match++;
													}
													break;
												case "lowerThan":
													var cellContent = parseFloat(this.dataArray[i][j].text);
													var filter = parseFloat(filter.value);
													if (cellContent < filter) {
														match++;
													}
													break;
												case "beforeEqual":
													if (typeof this.dataArray[i][j].text == "number"){ //greaterEqual
														var cellContent = parseFloat(this.dataArray[i][j].text);
														var filter = parseFloat(filter.value);
														if (cellContent <= filter) {
															match++;
														}
													} else {
														var cellContent = this.parseDate_(this.dataArray[i][j].text,false);
														var filter = this.parseDate_(filter.value);
														if ((cellContent != null && filter != null) && cellContent.getTime() <= filter.getTime()) {
															match++;
														}
													}
													break;
												case "afterEqual":
													if (typeof this.dataArray[i][j].text == "number"){ //lowerEqual
														var cellContent = parseFloat(this.dataArray[i][j].text);
														var filter = parseFloat(filter.value);
														if (cellContent >= filter) {
															match++;
														}
													} else {
														var cellContent = this.parseDate_(this.dataArray[i][j].text,true);
														var filter = this.parseDate_(filter.value);
														if ((cellContent != null && filter != null) && cellContent.getTime() >= filter.getTime()) {
															match++;
														}
													}
													break;
												default: break;
											}
										} catch (e) { }
									}
								}
							}
							j--;
						}
					}
				}
				if (match == this.filterArray.length) {
					tempExtract.push(this.dataArray[i]);
				}
				i--;
			}
		}
		this.dataFiltered = tempExtract.reverse();

		this.filteredArrayLength = tempExtract.length;
		if (this.offsetStart >= tempExtract.length) {
			this.offsetStart = 0;
		}
		if (tempExtract.length < this.offsetEnd) {
			this.offsetStart = ((tempExtract.length+1) - this.configuration.maxResults) > 0 ? ((tempExtract.length+1) - this.configuration.maxResults) : 0;
			this.offsetEnd = tempExtract.length;
		}
		if (this.offsetEnd < tempExtract.length) {
			this.offsetEnd = this.offsetStart + this.configuration.maxResults;
		}
		this.dataExtract = tempExtract.slice(this.offsetStart, this.offsetEnd);
	}
};
/**
 * @private
*/
AtviseDataProvider.prototype.fireDataChanged_ = function() {
	this.filter_();
	for (var i in this.listeners) {
		this.listeners[i](this.dataExtract);
	}
};
/**
 * @private
*/
AtviseDataProvider.prototype.increaseOffset_ = function(step) {
	var step = step == undefined ? this.configuration.maxResults : step;
	var nextOffsetStart = (this.offsetStart + step);
	var nextOffsetEnd = (this.offsetEnd + step);
	if (this.hasMore(nextOffsetStart, nextOffsetEnd)) {
		this.offsetStart += step;
		this.offsetEnd += step;
	} else {
		this.offsetStart = parseFloat(this.lastItemIndex()+2) - this.configuration.maxResults;
		this.offsetEnd = parseFloat(this.lastItemIndex()+2);
	}
};
/**
 * @private
*/
AtviseDataProvider.prototype.init_ = function(configuration) {
	if (configuration != undefined) {
		if (configuration.maxResults != undefined) {
			this.configuration.maxResults = configuration.maxResults;
		}
		if (configuration.sortingUp != undefined) {
			this.sortingUp = configuration.sortingUp;
		}
		if (configuration.sortedByColumn != undefined) {
			this.sortedByColumn = configuration.sortedByColumn;
		}
	}
	if (this.source.data.constructor.toString().indexOf("Array") != -1) {
		this.type = this.types.DATA_PROVIDER_TYPE_ARRAY;
		this.dataArray = this.source.data;
		this.offsetEnd = this.configuration.maxResults;
		this.sort(this.sortedByColumn, this.sortingUp);
		this.extract_(this.offsetStart, this.offsetEnd);
	} else if (this.source.type == this.types.DATA_PROVIDER_TYPE_XML) {
		this.type = this.types.DATA_PROVIDER_TYPE_XML;
		// TODO: handle xml...
	} else if (typeof this.source.data == "string") {
		this.type = this.types.DATA_PROVIDER_TYPE_SERVERSIDE;
		this.dataFn = this.source.data;
		this.offsetEnd = this.configuration.maxResults;
		this.params = this.source.params;
		this.sort(this.sortedByColumn, this.sortingUp);
		this.dataExtract = this.callDataFn_();
		this.dataArray = this.dataExtract;
		this.fireDataChanged_();
	}
};
/**
 * @private
*/
AtviseDataProvider.prototype.parseDate_ = function(dateString,low) {
	var date = null;
	low = (low == undefined || low)? true : false;
	var dateTime = dateString.split(" ");
	if (dateTime.length == 2) {
		var dateArray = dateTime[0].split("-");
		var timeArray = dateTime[1].split(":");
		if (dateArray.length == 3 && timeArray.length == 3) {
			date = new Date(dateArray[0], dateArray[1]-1, dateArray[2], timeArray[0], timeArray[1], timeArray[2]);
		}
	} else {
		var dateArray = dateTime[0].split("-");
		if (dateArray.length == 3 && low) {
			date = new Date(dateArray[0], dateArray[1]-1, dateArray[2], 0, 0, 0);
		}
		if (dateArray.length == 3 && !low) {
			date = new Date(dateArray[0], dateArray[1]-1, dateArray[2], 23, 59, 59);
		}
	}
	return date;
};
/**
 * @private
*/
AtviseDataProvider.prototype.parameterList_ = function() {
	var paramList = "";
	if (this.params != null && this.params != undefined) {
		for (var i in this.params) {
			paramList += "&" + i + "=" + this.params[i];
		}
	}
	return paramList;
};
/**
 * @private
*/
AtviseDataProvider.prototype.setCellStyle_ = function(rowNr, colNr, style, update) {
	if (this.dataArray[rowNr] != undefined && this.dataArray[rowNr][colNr] != undefined) {
		for (var styleEntry in style) {
			this.dataArray[rowNr][colNr][styleEntry] = style[styleEntry];
		}
	}
	if (update) {
		this.fireDataChanged_();
	}
};
/**
 * @private
*/
AtviseDataProvider.prototype.setProperties_ = function(obj, properties) {
	var overwrite = (arguments[2])?arguments[2]:false;
	if (typeof obj == "object") {
		for (var i in properties) {
			if(!obj[i] || overwrite) {
				if (typeof obj[i] == "object") {
					this._setProperties(obj[i], properties[i], overwrite);
				} else {
					obj[i] = properties[i];
				}
			}
		}
	}
	return obj;
};

var gElement = (base.gElement == undefined) ? document.getElementById(base.id) : base.gElement;
if (gElement == null || gElement == undefined || (gElement.nodeName != "g" && gElement.nodeName != "group")) {
	return null;
} else {
	function convert(paramValue, desiredType) {
		var action = null;
		var types = { "number": 0, "boolean": 1, "string": 2 };
		var numberToBool = function(x) {
			return (x > 0);
		};
		var numberToString = function(x) {
			return "" + x;
		};
		var boolToNumber = function(x) {
			return (x == false) ? 0 : 1;
		};
		var boolToString = function(x) {
			return "" + x;
		};
		var stringToNumber = function(x) {
			return parseFloat(x);
		};
		var stringToBool = function(x) {
			return (x == "true");
		};

		var numberFns = [null, numberToBool, numberToString];
		var boolFns = [boolToNumber, null, boolToString];
		var stringFns = [stringToNumber, stringToBool, null];
		var type = typeof paramValue;
		switch(type) {
			case "number": action = numberFns[types[desiredType]]; break;
			case "boolean": action = boolFns[types[desiredType]]; break;
			case "string": action = stringFns[types[desiredType]]; break;
			default: break;
		}
		var returnVal = paramValue;
		if (action != null) {
			returnVal = action(paramValue);
		}
		return returnVal;
	}
	var aTable = new AtviseTable(gElement);
	base.rowHeight = convert(base.rowHeight, "number");
	base.sortable = convert(base.sortable, "boolean");
	base.sortingUp = convert(base.sortingUp, "boolean");
	base.sortedByColumn = convert(base.sortedByColumn, "number");
	base.scrollbarSize = convert(base.scrollbarSize, "number");
	base.drawStatusBar = convert(base.drawStatusBar, "boolean");
	base.highlightCells = convert(base.highlightCells, "boolean");
	base.selectRow = convert(base.selectRow, "boolean");
	base.selectColumn = convert(base.selectColumn, "boolean");
	base.autoResize = convert(base.autoResize, "boolean");
	base.selectFixed = convert(base.selectFixed, "boolean");
	base.height = convert(base.height, "number");
	base.width = convert(base.width, "number");
	var config = {displayHeight: base.height, displayWidth: base.width, rowHeight: base.rowHeight, sortable: base.sortable, sortingUp: base.sortingUp, sortedByColumn: base.sortedByColumn, scrollbarSize: base.scrollbarSize, drawStatusBar: base.drawStatusBar, highlightCells: base.highlightCells, selectRow: base.selectRow, selectColumn: base.selectColumn, autoResize: base.autoResize, selectFixed: base.selectFixed};
	aTable._init(config);
	return aTable;
}
//Start - Scroll-function (part 2 / 2) ///////////////////////////////////////////////////
function MouseWheelHandler(e) {
	// cross-browser wheel delta
	var e = window.event || e; // old IE support
	var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail))); // up or down detection
	var scrollSteps= 5;

	if(delta==1){
		aTable._scroll(e, ["up", scrollSteps]);
	}

	if(delta==-1){
		aTable._scroll(e, ["down",scrollSteps]);
	}
	return false;
}
//End - Scroll-function (part 2 / 2) ///////////////////////////////////////////////////]]></code>
</script>
